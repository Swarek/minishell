/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_all2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 17:57:08 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:25:11 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_cmd_arg_stdin(char **cmd_arg_stdin)
{
	int	i;

	if (!cmd_arg_stdin)
		return ;
	i = 0;
	while (cmd_arg_stdin[i])
	{
		free(cmd_arg_stdin[i]);
		i++;
	}
	free(cmd_arg_stdin);
}

void	free_args(t_arg *args)
{
	t_arg	*current;
	t_arg	*next;

	if (!args)
		return ;
	current = args;
	while (current)
	{
		next = current->next;
		if (current->content)
		{
			free(current->content);
			current->content = NULL;
		}
		free(current);
		current = next;
	}
}

void	safe_free_cmds(t_cmd *cmds)
{
	t_cmd	*current_cmd;
	t_cmd	*next_cmd;

	current_cmd = cmds;
	while (current_cmd)
	{
		next_cmd = current_cmd->next;
		if (current_cmd->args)
			free_args(current_cmd->args);
		if (current_cmd->cmd_arg_stdin)
			safe_free_all_strings(&(current_cmd->cmd_arg_stdin));
		ft_safe_free((void **)&current_cmd);
		current_cmd = next_cmd;
	}
}

void	free_pipes(int **pipes, int nbr_pipes)
{
	int	i;

	if (!pipes)
		return ;
	i = 0;
	while (i < nbr_pipes)
	{
		ft_safe_free((void **)&pipes[i]);
		i++;
	}
	ft_safe_free((void **)&pipes);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_all2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 18:33:56 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 18:35:03 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	clean_child_pids(t_shell *shell)
{
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
}

void	clean_cmds(t_shell *shell)
{
	if (shell->cmds)
	{
		safe_free_cmds(shell->cmds);
		shell->cmds = NULL;
	}
}

void	clean_pipes(t_shell *shell)
{
	if (shell->pipes)
	{
		free_pipes(shell->pipes, shell->nbr_pipes);
		shell->pipes = NULL;
	}
}

void	clean_envp(t_shell *shell)
{
	char	**ptr;

	if (shell->envp)
	{
		ptr = shell->envp;
		while (*ptr)
			free(*ptr++);
		free(shell->envp);
		shell->envp = NULL;
	}
}

void	clean_all(t_shell *shell)
{
	if (!shell)
		return ;
	clean_child_pids(shell);
	clean_cmds(shell);
	clean_pipes(shell);
	clean_envp(shell);
	rl_cleanup_after_signal();
	rl_deprep_terminal();
	free(shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wait_and_cleanup_pipes.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 02:49:55 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:26:29 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	wait_and_cleanup(t_shell *shell)
{
	int	i;
	int	status;

	i = 0;
	while (i < shell->total_cmd_count)
	{
		if (waitpid(shell->child_pids[i], &status, 0) == -1)
		{
			error_msg("Waitpid failed\n");
			shell->exit_status = 1;
		}
		else if (i == shell->total_cmd_count - 1)
		{
			if (WIFEXITED(status))
				shell->exit_status = WEXITSTATUS(status);
			else if (WIFSIGNALED(status))
				shell->exit_status = 128 + WTERMSIG(status);
		}
		i++;
	}
	cleanup(shell, NULL);
	if (shell->infile != -1)
		close(shell->infile);
	if (shell->outfile != -1)
		close(shell->outfile);
}

void	cleanup(t_shell *shell, char **cmd)
{
	int	i;

	i = 0;
	while (i < shell->nbr_pipes)
	{
		if (shell->pipes[i])
		{
			close(shell->pipes[i][0]);
			close(shell->pipes[i][1]);
			free(shell->pipes[i]);
		}
		i++;
	}
	free(shell->pipes);
	shell->pipes = NULL;
	if (shell->infile != -1)
		close(shell->infile);
	if (cmd)
		safe_free_all_strings(&cmd);
	if (shell->outfile != -1)
		close(shell->outfile);
	if (shell->child_pids)
		ft_safe_free((void **)&(shell->child_pids));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_process.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 22:14:46 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:48:55 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	parent_process(t_shell *shell, pid_t pid)
{
	if (shell->infile > STDIN)
		close(shell->infile);
	if (shell->outfile > STDOUT)
		close(shell->outfile);
	shell->child_pids[shell->n_th_cmd] = pid;
	return (0);
}

void	close_pipes(t_shell *shell)
{
	int	i;

	i = 0;
	while (i < shell->total_cmd_count - 1)
	{
		close(shell->pipes[i][0]);
		close(shell->pipes[i][1]);
		i++;
	}
}

void	child_process(t_shell *shell)
{
	setup_child_signals();
	handle_io_redirections(shell);
	if (shell->there_is_redir_out < 0)
	{
		error_msg("Error setup redirection\n");
		exit(EXIT_FAILURE);
	}
	cut_the_cmd_plus_args(shell->cmds);
	if (shell->there_is_redir_out)
		dup2(shell->outfile, STDOUT_FILENO);
	if (shell->there_is_redir_in)
		dup2(shell->infile, STDIN_FILENO);
	setup_pipe_redirections(shell);
	close_pipes(shell);
	if (shell->infile > STDIN)
		close(shell->infile);
	if (shell->outfile > STDOUT)
		close(shell->outfile);
	if (do_the_execution(shell, shell->cmds, shell->envp) == -1)
		exit(1);
}

int	advance_to_next_command(t_shell *shell)
{
	if (shell->cmds->args)
	{
		while (shell->cmds && ft_strcmp(shell->cmds->args->type, "pipe") != 0)
			shell->cmds = shell->cmds->next;
		if (shell->cmds)
			shell->cmds = shell->cmds->next;
	}
	else
		return (-1);
	return (0);
}

int	pipes_process(t_shell *shell)
{
	pid_t	pid;

	shell->infile = dup(STDIN);
	shell->outfile = dup(STDOUT);
	while (shell->cmds)
	{
		pid = fork();
		if (pid == -1)
			return (error_msg("Fork failed\n"), -1);
		if (pid == 0)
		{
			child_process(shell);
		}
		else
			parent_process(shell, pid);
		shell->n_th_cmd++;
		if (advance_to_next_command(shell) == -1)
			break ;
		if (is_a_here_doc_in_the_cmd(shell->cmds))
			shell->nth_here_doc++;
	}
	close_pipes(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_for_here_doc.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/31 00:02:41 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/31 00:21:31 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

size_t	get_var_len(char *str, int *i, t_shell *shell)
{
	char	var[1024];
	char	*value;
	int		j;

	j = 0;
	(*i)++;
	if (str[*i] == '?')
	{
		(*i)++;
		return (ft_strlen(ft_itoa(shell->exit_status)));
	}
	while (str[*i] && (ft_isalnum(str[*i]) || str[*i] == '_'))
		var[j++] = str[(*i)++];
	var[j] = '\0';
	value = getenv(var);
	if (value)
		return (ft_strlen(value));
	return (0);
}

char	*get_var_value(char *str, int *i, t_shell *shell)
{
	char	var[1024];
	char	*value;
	int		j;

	j = 0;
	(*i)++;
	if (str[*i] == '?')
	{
		(*i)++;
		return (ft_itoa(shell->exit_status));
	}
	while (str[*i] && (ft_isalnum(str[*i]) || str[*i] == '_'))
		var[j++] = str[(*i)++];
	var[j] = '\0';
	value = getenv(var);
	if (value)
		return (ft_strdup(value));
	return (ft_strdup(""));
}

size_t	get_final_len(char *str, t_shell *shell)
{
	size_t	len;
	int		i;

	len = 0;
	i = 0;
	while (str[i])
	{
		if (str[i] == '$' && str[i + 1])
			len += get_var_len(str, &i, shell);
		else
		{
			len++;
			i++;
		}
	}
	return (len);
}

char	*replace_in_charstar(char **str, t_shell *shell)
{
	char	*new;
	char	*var_value;
	int		i;
	int		j;

	new = malloc(sizeof(char) * (get_final_len(*str, shell) + 1));
	if (!new)
		return (NULL);
	i = 0;
	j = 0;
	while ((*str)[i])
	{
		if ((*str)[i] == '$' && (*str)[i + 1])
		{
			var_value = get_var_value(*str, &i, shell);
			if (var_value == NULL)
				return (free(new), NULL);
			ft_strlcpy(new + j, var_value, ft_strlen(var_value) + 1);
			j += ft_strlen(var_value);
			free(var_value);
		}
		else
			new[j++] = (*str)[i++];
	}
	new[j] = '\0';
	free(*str);
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_io_redirections.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 06:35:42 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:49:43 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_arg	*last_redir_left(t_arg *args)
{
	t_arg	*last_redir_left;

	last_redir_left = NULL;
	while (args)
	{
		if (ft_strcmp(args->type, "redir_left") == 0)
			last_redir_left = args;
		if (ft_strcmp(args->type, "double_redir_left") == 0)
			last_redir_left = args;
		args = args->next;
	}
	return (last_redir_left);
}

t_arg	*last_redir_right(t_arg *args)
{
	t_arg	*last_redir_right;

	last_redir_right = NULL;
	while (args)
	{
		if (ft_strcmp(args->type, "redir_right") == 0)
			last_redir_right = args;
		if (ft_strcmp(args->type, "double_redir_right") == 0)
			last_redir_right = args;
		args = args->next;
	}
	return (last_redir_right);
}

static int	handle_input_redirection(t_shell *shell, t_arg *redir_left)
{
	char	*name_file;

	if (redir_left != NULL)
	{
		if (ft_strcmp(redir_left->type, "double_redir_left") == 0)
		{
			name_file = name_files_here_doc(shell->nth_here_doc);
			shell->infile = open(name_file, O_RDONLY);
		}
		else
			shell->infile = open(redir_left->next->content, O_RDONLY);
		if (shell->infile < 0)
		{
			shell->exit_status = 1;
			error_msg("Failed to open infile\n");
			return (-1);
		}
	}
	else
	{
		shell->infile = STDIN_FILENO;
	}
	return (0);
}

static int	handle_output_redirection(t_shell *shell, t_arg *redir_right)
{
	if (redir_right != NULL)
	{
		if (ft_strcmp(redir_right->type, "redir_right") == 0)
			shell->outfile = open(redir_right->next->content,
					O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (ft_strcmp(redir_right->type, "double_redir_right") == 0)
			shell->outfile = open(redir_right->next->content,
					O_WRONLY | O_CREAT | O_APPEND, 0644);
		if (shell->outfile < 0)
		{
			shell->exit_status = 1;
			error_msg("Failed to open outfile\n");
			return (-1);
		}
	}
	else
	{
		shell->outfile = STDOUT_FILENO;
	}
	return (0);
}

int	handle_io_redirections(t_shell *shell)
{
	t_arg	*redir_left;
	t_arg	*redir_right;

	redir_left = last_redir_left(shell->cmds->args);
	redir_right = last_redir_right(shell->cmds->args);
	if (handle_input_redirection(shell, redir_left) == -1)
		return (-1);
	if (handle_output_redirection(shell, redir_right) == -1)
	{
		if (redir_left != NULL && shell->infile != STDIN_FILENO)
			close(shell->infile);
		return (-1);
	}
	if (redir_left != NULL)
		shell->there_is_redir_in = 1;
	if (redir_right != NULL)
		shell->there_is_redir_out = 1;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   here_doc_management.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/08 04:54:57 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/31 00:24:34 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	write_to_temp(int fd, char *line)
{
	if (!line)
	{
		if (write(fd, "\n\n", ft_strlen(line)) == -1)
			return (-1);
	}
	if (write(fd, line, ft_strlen(line)) == -1)
		return (error_msg("Problem writing to temp.txt"), free(line), close(fd),
			-1);
	if (write(fd, "\n", 1) == -1)
		return (error_msg("Problem writing newline to temp.txt"), free(line),
			close(fd), -1);
	return (0);
}

int	here_doc_management(char *limiter, char *name_file, t_shell *shell)
{
	int		fd;
	char	*line;
	size_t	len;

	fd = open(name_file, O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
		return (error_msg("Problem opening temp.txt"));
	while (1)
	{
		write(1, "> ", 2);
		line = get_next_line(0);
		if (!line)
			break ;
		len = ft_strlen(line);
		if (len > 0 && line[len - 1] == '\n')
			line[len - 1] = '\0';
		if (ft_strcmp(line, limiter) == 0 || len == 0)
			break ;
		line = replace_in_charstar(&line, shell);
		ft_printf("%s\n", line);
		if (write_to_temp(fd, line) == -1)
			return (-1);
		free(line);
	}
	free(line);
	close(fd);
	return (0);
}

int	delete_all_temp_files(int total_here_doc)
{
	int		i;
	char	*name_file;

	i = 0;
	while (i < total_here_doc)
	{
		name_file = name_files_here_doc(i);
		if (unlink(name_file) == -1)
			return (error_msg("Problem deleting temp.txt"), -1);
		free(name_file);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   name_files_here_doc.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 01:46:38 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/31 00:10:35 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_a_here_doc_in_the_cmd(t_cmd *cmd)
{
	t_arg	*tmp;

	if (!cmd)
		return (0);
	tmp = cmd->args;
	while (tmp)
	{
		if (tmp)
		{
			if (ft_strcmp(tmp->type, "double_redir_left") == 0)
				return (1);
		}
		tmp = tmp->next;
	}
	return (0);
}

int	count_here_doc_separated_by_pipes(t_cmd *cmd)
{
	int		count;
	t_arg	*tmp;

	count = 0;
	while (cmd)
	{
		tmp = cmd->args;
		while (tmp)
		{
			if (tmp)
			{
				if (ft_strcmp(tmp->type, "double_redir_left") == 0)
				{
					count++;
					break ;
				}
			}
			tmp = tmp->next;
		}
		cmd = cmd->next;
	}
	return (count);
}

t_arg	*verif_here_doc_and_find_limiter(t_arg *args)
{
	t_arg	*tmp;
	t_arg	*limiter;

	tmp = args;
	limiter = NULL;
	while (tmp)
	{
		if (ft_strcmp(tmp->type, "double_redir_left") == 0)
		{
			tmp = tmp->next;
			limiter = tmp;
		}
		tmp = tmp->next;
	}
	return (limiter);
}

int	handle_here_doc(t_shell *shell)
{
	int		i;
	int		total_here_doc;
	t_arg	*limiter;
	t_cmd	*cmds;

	i = 0;
	cmds = shell->cmds;
	total_here_doc = count_here_doc_separated_by_pipes(shell->cmds);
	while (i < total_here_doc)
	{
		limiter = verif_here_doc_and_find_limiter(cmds->args);
		if (!limiter)
			continue ;
		if (here_doc_management(limiter->content, name_files_here_doc(i), shell) == -1)
			return (-1);
		if (cmds->next)
		{
			cmds = cmds->next;
		}
		while (is_a_here_doc_in_the_cmd(cmds) == 0)
			cmds = cmds->next;
		i++;
	}
	return (0);
}

// Will return the name of the temp file with the nbr
char	*name_files_here_doc(int nbr)
{
	char	*name;
	char	*nbr_str;

	nbr_str = ft_itoa(nbr);
	if (!nbr_str)
		return (NULL);
	name = ft_strjoin("temp", nbr_str);
	free(nbr_str);
	return (name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   setup_pipe_redirections.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 18:41:49 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 18:21:37 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	first_pipe_redirections(t_shell *shell)
{
	if (shell->there_is_redir_in == 0)
	{
		if (dup2(shell->infile, STDIN_FILENO) == -1)
			return (-1);
	}
	if (shell->there_is_redir_out == 0)
	{
		if (dup2(shell->pipes[shell->n_th_cmd][1], STDOUT_FILENO) == -1)
			return (-1);
	}
	return (0);
}

int	last_pipe_redirections(t_shell *shell)
{
	if (shell->there_is_redir_in == 0)
	{
		if (dup2(shell->pipes[shell->n_th_cmd - 1][0], STDIN_FILENO) == -1)
			return (-1);
	}
	if (shell->there_is_redir_out == 0)
	{
		if (dup2(shell->outfile, STDOUT_FILENO) == -1)
			return (-1);
	}
	return (0);
}

int	middle_pipe_redirections(t_shell *shell)
{
	if (shell->there_is_redir_in == 0)
	{
		if (dup2(shell->pipes[shell->n_th_cmd - 1][0], STDIN_FILENO) == -1)
			return (-1);
	}
	if (shell->there_is_redir_out == 0)
	{
		if (dup2(shell->pipes[shell->n_th_cmd][1], STDOUT_FILENO) == -1)
			return (-1);
	}
	return (0);
}

int	setup_pipe_redirections(t_shell *shell)
{
	if (shell->n_th_cmd == 0)
		first_pipe_redirections(shell);
	else if (shell->n_th_cmd == shell->total_cmd_count - 1)
		last_pipe_redirections(shell);
	else
		middle_pipe_redirections(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   solo_cmd.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 21:22:35 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:49:05 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	single_cmd(t_shell *shell)
{
	t_arg	*current;

	current = shell->cmds->args;
	while (current && ft_strcmp(current->type, "command") != 0)
		current = current->next;
	if (!current)
		return (execute_solo(shell));
	if (is_built_in(shell->cmds->cmd_arg_stdin))
	{
		shell->exit_status = execute_built_in(shell, shell->cmds->cmd_arg_stdin,
				&shell->envp);
		return (shell->exit_status);
	}
	else
	{
		execute_solo(shell);
		if (shell->infile > STDIN)
			close(shell->infile);
		if (shell->outfile > STDOUT)
			close(shell->outfile);
		return (shell->exit_status);
	}
}

// Iniatiate all needed and call single_cmd to exec
int	starting_one_cmd(t_shell *shell)
{
	int	i;

	i = 0;
	if (shell == NULL || shell->cmds == NULL || shell->cmds->args == NULL)
		return (-1);
	if (handle_io_redirections(shell) == -1)
		return (-1);
	cut_the_cmd_plus_args(shell->cmds);
	if (single_cmd(shell) == -1)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_exec.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 23:04:23 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:44:33 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	any_empty_cmd(t_cmd *cmd)
{
	t_arg	*arg;

	while (cmd)
	{
		arg = cmd->args;
		if (arg == NULL)
			return (1);
		while (arg)
		{
			if (arg->content == NULL)
				return (1);
			arg = arg->next;
		}
		cmd = cmd->next;
	}
	return (0);
}

int	exec_it(t_shell *shell)
{
	g_received_signal = 10;
	if (shell == NULL || shell->cmds == NULL
		|| shell->cmds->args == NULL || any_empty_cmd(shell->cmds))
		return (0);
	if (all_init_for_pipes_cmds(shell) == -1)
		return (-1);
	if (count_cmd(shell->cmds) == 0)
		return (0);
	handle_here_doc(shell);
	if (shell->nbr_pipes == 0)
	{
		if (starting_one_cmd(shell) == -1)
		{
			clean_up_for_error_init(shell, shell->nbr_pipes);
			return (-1);
		}
	}
	else if (shell->nbr_pipes >= 1)
	{
		pipes_process(shell);
		wait_and_cleanup(shell);
	}
	if (shell->nth_here_doc > 0)
		delete_all_temp_files(shell->nth_here_doc + 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   doing_built_in.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 01:59:53 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:40:43 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_built_in(char **args)
{
	if (ft_strcmp(args[0], "echo") == 0)
		return (1);
	if (ft_strcmp(args[0], "cd") == 0)
		return (1);
	if (ft_strcmp(args[0], "pwd") == 0)
		return (1);
	if (ft_strcmp(args[0], "export") == 0)
		return (1);
	if (ft_strcmp(args[0], "env") == 0)
		return (1);
	if (ft_strcmp(args[0], "unset") == 0)
		return (1);
	if (ft_strcmp(args[0], "exit") == 0)
		return (1);
	return (0);
}

int	is_built_in_t_args(t_arg *args)
{
	if (ft_strcmp(args->content, "echo") == 0)
		return (1);
	if (ft_strcmp(args->content, "cd") == 0)
		return (1);
	if (ft_strcmp(args->content, "pwd") == 0)
		return (1);
	if (ft_strcmp(args->content, "export") == 0)
		return (1);
	if (ft_strcmp(args->content, "env") == 0)
		return (1);
	if (ft_strcmp(args->content, "unset") == 0)
		return (1);
	if (ft_strcmp(args->content, "exit") == 0)
		return (1);
	return (0);
}

int	execute_built_in(t_shell *shell, char **cmd_arg_stdin, char ***envp)
{
	if (ft_strcmp(cmd_arg_stdin[0], "echo") == 0)
		return (ft_echo(shell));
	if (ft_strcmp(cmd_arg_stdin[0], "cd") == 0)
		return (ft_cd(shell));
	if (ft_strcmp(cmd_arg_stdin[0], "pwd") == 0)
		return (ft_pwd(shell));
	if (ft_strcmp(cmd_arg_stdin[0], "export") == 0)
		return (ft_export(shell->cmds->args, envp));
	if (ft_strcmp(cmd_arg_stdin[0], "env") == 0)
		return (ft_env(*envp, shell), 0);
	if (ft_strcmp(cmd_arg_stdin[0], "unset") == 0)
		return (ft_unset(shell->cmds->args, envp), 0);
	if (ft_strcmp(cmd_arg_stdin[0], "exit") == 0)
		return (ft_exit(shell, shell->cmds->args));
	return (127);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 05:56:18 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:04:25 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	go_last_place(t_shell *shell)
{
	char	*oldpwd;

	oldpwd = ft_getenv(shell->envp, "OLDPWD");
	if (!oldpwd)
	{
		error_msg("cd: OLDPWD not set\n");
		shell->exit_status = 1;
		return (shell->exit_status);
	}
	if (chdir(oldpwd) == -1)
	{
		perror("cd");
		shell->exit_status = 1;
		return (shell->exit_status);
	}
	ft_printf("%s\n", oldpwd);
	return (0);
}

static int	go_home(t_shell *shell)
{
	char	*home;

	home = ft_getenv(shell->envp, "HOME");
	if (!home)
	{
		ft_printf("cd: HOME not set\n");
		shell->exit_status = 1;
		return (shell->exit_status);
	}
	if (chdir(home) == -1)
	{
		perror("cd");
		shell->exit_status = 1;
		return (shell->exit_status);
	}
	return (0);
}

static int	end_cd(t_shell *shell)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		perror("cd");
		shell->exit_status = 1;
		return (shell->exit_status);
	}
	setenv("OLDPWD", ft_getenv(shell->envp, "PWD"), 1);
	setenv("PWD", cwd, 1);
	return (free(cwd), shell->exit_status = 0, 0);
}

int	ft_cd(t_shell *shell)
{
	char	**arg;

	arg = shell->cmds->cmd_arg_stdin;
	if (arg == NULL || arg[0] == NULL)
		return (0);
	if (arg[1] != NULL && arg[2] != NULL)
		return (error_msg("cd: too many arguments\n"),
			shell->exit_status = 1, 1);
	if (!arg[1])
	{
		if (go_home(shell) != 0)
			return (shell->exit_status);
	}
	else if (arg[1][0] == '-' && arg[1][1] == '\0')
	{
		if (go_last_place(shell) != 0)
			return (shell->exit_status);
	}
	else
	{
		if (chdir(arg[1]) == -1)
			return (perror("cd"), shell->exit_status = 1, 1);
	}
	return (end_cd(shell));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 22:35:19 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 16:19:57 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_flag_echo(char *flag)
{
	int	i;

	i = 1;
	if (flag == NULL)
		return (0);
	if (!(flag[0] == '-'))
		return (0);
	while (flag[i] && flag[i] == 'n')
		i++;
	if (flag[i] == '\0')
		return (1);
	return (0);
}

// Return 0 if iarg_stdin[1] is not a -n(n xtimes)
// Return x as the index of the first arg which is not a flag.
int	handle_multiple_n_echo(t_shell *shell)
{
	int	i;

	i = 1;
	while (shell->cmds->cmd_arg_stdin[i] != NULL)
	{
		if (!(is_flag_echo(shell->cmds->cmd_arg_stdin[i])))
			return (i);
		i++;
	}
	if (is_flag_echo(shell->cmds->cmd_arg_stdin[i - 1]))
		return (-2);
	return (1);
}

int	ft_echo(t_shell *shell)
{
	int	no_newline;
	int	i;

	no_newline = 0;
	i = 1;
	if (!shell->cmds->cmd_arg_stdin[1])
		return (ft_putchar_fd('\n', shell->outfile), 0);
	i = handle_multiple_n_echo(shell);
	if (i > 1 || i == -2)
		no_newline = 1;
	if (i == -2)
		return (0);
	while (shell->cmds->cmd_arg_stdin[i] != NULL)
	{
		ft_putstr_fd(shell->cmds->cmd_arg_stdin[i], shell->outfile);
		if (shell->cmds->cmd_arg_stdin[i + 1] != NULL)
			ft_putchar_fd(' ', shell->outfile);
		i++;
	}
	if (!no_newline)
		ft_putchar_fd('\n', shell->outfile);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:06:09 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/27 18:59:19 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_env(char **envp, t_shell *shell)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		ft_putstr_fd(envp[i], shell->outfile);
		ft_putchar_fd('\n', shell->outfile);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:07:45 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:41:12 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_numeric(char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (0);
	if (str[i] == '-' || str[i] == '+')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

int	ft_exit(t_shell *shell, t_arg *args)
{
	int	exit_code;

	(void)shell;
	if (!shell->cmds->cmd_arg_stdin[1])
		exit(-1);
	args = args->next;
	if (!is_numeric(args->content))
	{
		ft_putstr_fd("exit: numeric argument required\n", STDERR_FILENO);
		exit(255);
	}
	if (args->next)
	{
		ft_putstr_fd("exit: too many arguments\n", STDERR_FILENO);
		return (1);
	}
	exit_code = ft_atoi(args->content);
	exit(exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 06:35:14 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:42:11 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	declare_and_sort(t_env *env)
{
	t_env	*current;
	t_env	*smallest;
	int		len;

	current = env;
	while (current)
	{
		current->declared = 0;
		current = current->next;
	}
	len = len_env(env);
	while (len-- > 0)
	{
		smallest = find_smallest_undeclared(env);
		if (smallest)
		{
			smallest->declared = 1;
			ft_printf("declare -x %s=\"%s\"\n", smallest->name,
				smallest->value);
		}
	}
	return (0);
}

int	t_env_to_array(t_env *env, char ***envp)
{
	t_env	*current;
	int		i;

	*envp = malloc(sizeof(char *) * (len_env(env) + 1));
	if (!*envp)
		return (1);
	i = 0;
	current = env;
	while (current)
	{
		(*envp)[i] = ft_strdup(current->line);
		if (!(*envp)[i])
		{
			while (i-- > 0)
			{
				free((*envp)[i]);
				free(*envp);
				return (1);
			}
		}
		i++;
		current = current->next;
	}
	(*envp)[i] = NULL;
	return (0);
}

int	update_existing_node(t_env *existing_node, char *name, char *value)
{
	char	*temp_line;
	char	*temp;

	free(existing_node->value);
	existing_node->value = ft_strdup(value);
	free(existing_node->line);
	temp_line = ft_strjoin(name, "=");
	if (!temp_line)
		return (1);
	temp = ft_strjoin(temp_line, value);
	free(temp_line);
	if (!temp)
		return (1);
	existing_node->line = temp;
	return (0);
}

int	process_arg(t_arg *arg, t_env **env)
{
	t_env	*existing_node;
	char	*name;
	char	*value;

	if (is_valid_identifier(arg->content) && ft_strchr(arg->content, '='))
	{
		name = extract_name(arg->content);
		value = extract_value(arg->content);
		existing_node = find_no_na(*env, name);
		if (existing_node)
		{
			if (update_existing_node(existing_node, name, value) != 0)
				return (free(name), free(value), 1);
		}
		else
			*env = add_node(*env, create_node(arg->content));
		free(name);
		free(value);
	}
	else
		error_msg("export: not a valid identifier\n");
	return (0);
}

int	ft_export(t_arg *args, char ***envp)
{
	t_env	*env;

	env = create_t_env(*envp);
	if (!env)
		return (1);
	if (count_arguments_for_t_arg(args) == 1)
	{
		declare_and_sort(env);
		return (free_env(env), 0);
	}
	args = args->next;
	edit_args_for_export(args);
	while (args)
	{
		if (process_arg(args, &env) != 0)
			return (free_env(env), 1);
		args = args->next;
	}
	safe_free_all_strings(envp);
	if (t_env_to_array(env, envp) != 0)
		return (free_env(env), 1);
	free_env(env);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export_extracts.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 17:37:13 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:37:38 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*extract_name(const char *content)
{
	int		len;
	char	*name;
	int		i;

	len = 0;
	while (content[len] && content[len] != '=')
		len++;
	name = malloc(sizeof(char) * (len + 1));
	if (!name)
		return (NULL);
	i = 0;
	while (i < len)
	{
		name[i] = content[i];
		i++;
	}
	name[len] = '\0';
	return (name);
}

char	*extract_value(const char *content)
{
	char	*equal_sign;
	char	*value;

	equal_sign = ft_strchr(content, '=');
	if (!equal_sign)
		return (NULL);
	value = ft_strdup(equal_sign + 1);
	return (value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 16:28:39 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:42:11 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	len_env(t_env *env)
{
	t_env	*current;
	int		len;

	len = 0;
	current = env;
	while (current)
	{
		len++;
		current = current->next;
	}
	return (len);
}

int	is_valid_identifier(char *str)
{
	int	i;

	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	i = 1;
	while (str[i] && str[i] != '=')
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

void	free_env(t_env *env)
{
	t_env	*temp;

	while (env)
	{
		temp = env;
		env = env->next;
		free(temp->name);
		free(temp->value);
		free(temp->line);
		free(temp);
	}
}

t_env	*find_no_na(t_env *env, const char *name)
{
	t_env	*current;

	current = env;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

t_env	*find_smallest_undeclared(t_env *env)
{
	t_env	*current;
	t_env	*smallest;

	current = env;
	smallest = NULL;
	while (current)
	{
		if (current->declared == 0 && (smallest == NULL
				|| ft_strcmp(current->name, smallest->name) < 0))
			smallest = current;
		current = current->next;
	}
	return (smallest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_pwd.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 05:55:10 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 10:23:40 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_pwd(t_shell *shell)
{
	char	cwd[PATH_MAX];

	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		ft_putstr_fd(cwd, shell->outfile);
		ft_putchar_fd('\n', shell->outfile);
	}
	else
		return (error_msg("pwd: error retrieving current directory\n"), 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:00:31 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:43:10 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_unset(t_arg *args, char ***env)
{
	int		j;
	size_t	len;

	args = args->next;
	while (args)
	{
		j = 0;
		len = ft_strlen(args->content);
		while ((*env)[j])
		{
			if (ft_strncmp((*env)[j], args->content, len) == 0
				&& (*env)[j][len] == '=')
			{
				free((*env)[j]);
				while ((*env)[j])
				{
					(*env)[j] = (*env)[j + 1];
					j++;
				}
				break ;
			}
			j++;
		}
		args = args->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execution.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/06 02:55:26 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 17:48:13 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fonction pour exécuter la commande
static void	execute_command(t_shell *shell, t_cmd *cmd, char *path)
{
	if (execve(path, cmd->cmd_arg_stdin, shell->envp) == -1)
	{
		if (access(path, F_OK) == 0 && access(path, X_OK) != 0)
		{
			free(path);
			perror("execve error");
			exit(126);
		}
		free(path);
		perror("execve error");
		exit(127);
	}
}

// Fonction auxiliaire pour préparer l'exécution
static char	*prepare_execution(t_shell *shell, t_cmd *cmd)
{
	char	*path;

	if (!cmd || !cmd->args || !cmd->args->content)
	{
		perror("Command content is NULL");
		exit(127);
	}
	if (is_real_cmd_in_cmds(cmd) == 0 || !cmd->cmd_arg_stdin)
	{
		perror("No command found");
		exit(127);
	}
	path = find_command_path(shell, cmd->cmd_arg_stdin[0], shell->envp);
	if (!path)
	{
		perror("execve error");
		exit(shell->exit_status);
	}
	if (!cmd->cmd_arg_stdin)
	{
		perror("Command arguments are NULL");
		free(path);
		exit(127);
	}
	return (path);
}

// Fonction principale pour effectuer l'exécution
int	do_the_execution(t_shell *shell, t_cmd *cmd, char **envp)
{
	char	*path;

	(void)envp;
	path = prepare_execution(shell, cmd);
	execute_command(shell, cmd, path);
	free(path);
	return (0);
}

void	child_process_execute_solo(t_shell *shell)
{
	setup_child_signals();
	dup2(shell->infile, STDIN_FILENO);
	dup2(shell->outfile, STDOUT_FILENO);
	if (shell->infile > STDIN)
		close(shell->infile);
	if (shell->outfile > STDOUT)
		close(shell->outfile);
	if (do_the_execution(shell, shell->cmds, shell->envp) == -1)
		exit(1);
}

// Fonction pour exécuter une commande seule
int	execute_solo(t_shell *shell)
{
	pid_t	pid;
	int		status;

	status = -1;
	pid = fork();
	if (pid == -1)
	{
		error_msg("Fork failed\n");
		return (shell->exit_status = 1, -1);
	}
	if (pid == 0)
		child_process_execute_solo(shell);
	else
	{
		waitpid(pid, &status, 0);
		if (status == -1)
			return (0);
		if (WIFEXITED(status))
			shell->exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			shell->exit_status = 128 + WTERMSIG(status);
		else
			shell->exit_status = 1;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 22:32:29 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:01:48 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fonction auxiliaire pour créer le chemin complet de la commande
static char	*create_command_path(char *path, char *command)
{
	char	*temp;
	char	*full_path;

	if (path == NULL)
		return (NULL);
	if (path[ft_strlen(path) - 1] != '/')
	{
		temp = ft_strjoin(path, "/");
		if (!temp)
			return (NULL);
	}
	else
	{
		temp = ft_strdup(path);
	}
	if (!temp)
		return (NULL);
	full_path = ft_strjoin(temp, command);
	free(temp);
	return (full_path);
}

// Fonction auxiliaire pour vérifier l'accès au chemin de la commande
static char	*verify_command_access(t_shell *shell, char *path, char *command)
{
	char	*command_path;

	if (!path)
	{
		shell->exit_status = 127;
		return (NULL);
	}
	command_path = create_command_path(path, command);
	if (!command_path)
	{
		free(path);
		shell->exit_status = 12;
		return (NULL);
	}
	if (access(command_path, X_OK) == 0)
	{
		free(path);
		return (command_path);
	}
	if (access(command_path, F_OK) == 0)
		shell->exit_status = 126;
	else
		shell->exit_status = 127;
	free(command_path);
	return (free(path), NULL);
}

// Nouvelle fonction pour rechercher la commande dans PATH
static char	*search_in_path(t_shell *shell, char *command, char **paths)
{
	int		i;
	char	*command_path;

	i = 0;
	while (paths[i] != NULL)
	{
		command_path = verify_command_access(shell, ft_strdup(paths[i]),
				command);
		if (command_path)
		{
			safe_free_all_strings(&paths);
			return (command_path);
		}
		i++;
	}
	return (NULL);
}

// Fonction pour trouver le chemin de la commande
char	*get_path_from_env(t_shell *shell, char *command, char **envp)
{
	char	**paths;
	char	*command_path;
	int		i;

	i = 0;
	while (envp[i] != NULL && ft_strncmp(envp[i], "PATH=", 5) != 0)
		i++;
	if (!envp[i])
	{
		shell->exit_status = 127;
		return (NULL);
	}
	paths = ft_split(envp[i] + 5, ':');
	if (paths == NULL)
	{
		shell->exit_status = 12;
		return (NULL);
	}
	command_path = search_in_path(shell, command, paths);
	if (command_path)
		return (command_path);
	safe_free_all_strings(&paths);
	shell->exit_status = 127;
	return (NULL);
}

char	*find_command_path(t_shell *shell, char *command, char **envp)
{
	if (!command || *command == '\0' || ft_str_is_whitespace(command)
		|| envp == NULL)
	{
		shell->exit_status = 127;
		return (NULL);
	}
	if (is_absolute_or_relative_path(command))
	{
		if (access(command, F_OK) == 0 && access(command, X_OK) != 0)
		{
			shell->exit_status = 126;
			return (NULL);
		}
		if (access(command, X_OK) == 0)
			return (ft_strdup(command));
		shell->exit_status = 127;
		return (NULL);
	}
	return (get_path_from_env(shell, command, envp));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   relative_absolute_path.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 11:11:50 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:42:56 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	**build_new_cmd(char *path, char **cmd, int args_count)
{
	char	**new_cmd;
	int		j;

	new_cmd = malloc(sizeof(char *) * (args_count + 2));
	if (!new_cmd)
		return (NULL);
	new_cmd[0] = ft_strdup("/bin/sh");
	new_cmd[1] = ft_strdup(path);
	j = 1;
	while (j < args_count)
	{
		new_cmd[j + 1] = ft_strdup(cmd[j]);
		j++;
	}
	new_cmd[args_count + 1] = NULL;
	return (new_cmd);
}

int	execute_with_shell(char *path, char **cmd, char **envp, int args_count)
{
	char	**new_cmd;
	int		j;

	new_cmd = build_new_cmd(path, cmd, args_count);
	if (!new_cmd)
	{
		perror("malloc error");
		exit(12);
	}
	execve("/bin/sh", new_cmd, envp);
	perror("execve error");
	j = 0;
	while (new_cmd[j])
	{
		free(new_cmd[j]);
		j++;
	}
	free(new_cmd);
	return (-1);
}

int	is_absolute_or_relative_path(char *command)
{
	if (!command)
		return (0);
	return (command[0] == '/' || (command[0] == '.' && command[1] == '/')
		|| (command[0] == '.' && command[1] == '.' && command[2] == '/'));
}

char	*handle_paths(char *command)
{
	if (access(command, X_OK) == 0)
		return (ft_strdup(command));
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   reading_line.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 20:59:11 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:44:23 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	**init_colors(void)
{
	char	**colors;

	colors = malloc(sizeof(char *) * 15);
	if (!colors)
		return (NULL);
	colors[0] = BOLD_COLOR_BLUE;
	colors[1] = COLOR_RED;
	colors[2] = COLOR_GREEN;
	colors[3] = COLOR_YELLOW;
	colors[4] = COLOR_BLUE;
	colors[5] = COLOR_PURPLE;
	colors[6] = COLOR_CYAN;
	colors[7] = COLOR_WHITE;
	colors[8] = BOLD_COLOR_RED;
	colors[9] = BOLD_COLOR_GREEN;
	colors[10] = BOLD_COLOR_YELLOW;
	colors[11] = COLOR_BLACK;
	colors[12] = BOLD_COLOR_PURPLE;
	colors[13] = BOLD_COLOR_CYAN;
	colors[14] = NULL;
	return (colors);
}

static char	*get_colored_prompt(int color)
{
	char	cwd[PATH_MAX];
	char	*current_dir;
	char	*colored_prompt;
	char	*prompt;
	char	**colors;

	colors = init_colors();
	if (!colors)
		return (NULL);
	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		current_dir = ft_strrchr(cwd, '/');
		if (current_dir != NULL)
			current_dir++;
		else
			current_dir = cwd;
		colored_prompt = ft_strjoin(colors[color % 14], current_dir);
		prompt = ft_strjoin(colored_prompt, " minishell> ");
		free(colored_prompt);
		colored_prompt = ft_strjoin(prompt, RESET_COLOR);
		free(prompt);
	}
	else
		colored_prompt = ft_strdup("minishell>");
	return (free(colors), colored_prompt);
}

char	*reading_line(int color)
{
	char			*line;
	char			*prompt;
	struct termios	term;

	tcgetattr(STDIN_FILENO, &term);
	if (g_received_signal == SIGINT && !(term.c_lflag & ICANON))
	{
		line = readline("");
	}
	else
	{
		prompt = get_colored_prompt(color);
		line = readline(prompt);
		free(prompt);
	}
	if (line && *line)
		add_history(line);
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   all_init_for_pipes_cmds.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 03:06:09 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:25:53 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	clean_up_for_error_init(t_shell *shell, int pipe_count)
{
	int	i;

	if (shell->pipes)
	{
		i = 0;
		while (i < pipe_count)
		{
			if (shell->pipes[i])
				free(shell->pipes[i]);
			i++;
		}
		free(shell->pipes);
		shell->pipes = NULL;
	}
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
}

static int	init_pipes(t_shell *shell)
{
	int	i;

	if (shell->nbr_pipes <= 0)
		return (shell->pipes = NULL, 0);
	shell->pipes = malloc(sizeof(int *) * shell->nbr_pipes);
	if (!shell->pipes)
		return (error_msg("Memory allocation failed\n"), -1);
	i = 0;
	while (i < shell->nbr_pipes)
	{
		shell->pipes[i] = malloc(2 * sizeof(int));
		if (!shell->pipes[i])
		{
			clean_up_for_error_init(shell, i);
			return (error_msg("Memory allocation failed\n"), -1);
		}
		if (pipe(shell->pipes[i]) == -1)
		{
			clean_up_for_error_init(shell, i);
			return (error_msg("Pipe creation failed\n"), -1);
		}
		i++;
	}
	return (0);
}

static int	init_child_pids(t_shell *shell)
{
	if (shell->total_cmd_count <= 0)
	{
		shell->child_pids = NULL;
		return (0);
	}
	shell->child_pids = malloc(sizeof(pid_t) * shell->total_cmd_count);
	if (!shell->child_pids)
	{
		clean_up_for_error_init(shell, shell->nbr_pipes);
		return (error_msg("Memory allocation failed\n"), -1);
	}
	return (0);
}

static void	initiates_type_cmd(t_shell *shell)
{
	int		i;
	t_cmd	*tmp;

	i = 0;
	if (shell == NULL)
		return ;
	tmp = shell->cmds;
	while (tmp)
	{
		find_arg_add_type_cmd(shell, tmp->args);
		tmp = tmp->next;
	}
}

int	all_init_for_pipes_cmds(t_shell *shell)
{
	if (shell->pipes)
	{
		free_pipes(shell->pipes, shell->nbr_pipes);
		shell->pipes = NULL;
	}
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
	shell->nbr_pipes = count_pipe(shell->cmds);
	shell->total_cmd_count = shell->nbr_pipes + 1;
	shell->there_is_redir_out = 0;
	shell->n_th_cmd = 0;
	if (init_pipes(shell) == -1)
		return (clean_up_for_error_init(shell, 0), -1);
	if (init_child_pids(shell) == -1)
	{
		clean_up_for_error_init(shell, shell->nbr_pipes);
		return (-1);
	}
	initiates_type_cmd(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 14:15:49 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 23:13:05 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_received_signal_in_main(t_shell *shell)
{
	if (g_received_signal == SIGINT)
		shell->last_exit_status = 130;
	else if (g_received_signal == SIGQUIT)
		shell->last_exit_status = 131;
	g_received_signal = 0;
}

int	main1(char **envp, t_shell **shell)
{
	*shell = init_struct_shell(envp);
	if (!*shell)
		return (-1);
	setup_signals();
	return (0);
}

int	main2(char *line, t_cmd **cmds, t_shell *shell)
{
	int	ret;

	ret = parse_it(line, cmds);
	free(line);
	if (ret != 0)
	{
		if (*cmds)
		{
			safe_free_cmds(*cmds);
			*cmds = NULL;
		}
		return (1);
	}
	str_arg_in_null(*cmds);
	expand_env_vars_in_cmds_tab(cmds, *shell);
	return (0);
}

int	main3(t_cmd **cmds, t_shell *shell)
{
	if (error_if_subsequent_commands(cmds) == -1
		|| error_if_unclosed_parentheses(cmds) == -1 || error_in_filename(cmds))
	{
		ft_printf("Syntax error\n");
		if (*cmds)
		{
			safe_free_cmds(*cmds);
			*cmds = NULL;
			shell->cmds = NULL;
		}
		clean_all(shell);
		return (2);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main3.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 14:19:31 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 23:20:10 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	main4(t_cmd **cmds, t_shell *shell)
{
	type_to_file_in_args1(cmds);
	replace_exit_status_in_cmds_tab(cmds, shell);
	shell->cmds = *cmds;
	if (exec_it(shell) == -1)
	{
		if (*cmds)
		{
			safe_free_cmds(*cmds);
			*cmds = NULL;
			shell->cmds = NULL;
		}
		clean_all(shell);
		return (-1);
	}
	return (0);
}

void	main5(t_cmd **cmds, t_shell *shell)
{
	if (*cmds)
	{
		safe_free_cmds(*cmds);
		*cmds = NULL;
		shell->cmds = NULL;
	}
}

int	main6(char **line, t_shell *shell, int color)
{
	initialize_shell_values(shell);
	if (g_received_signal)
		handle_received_signal_in_main(shell);
	*line = reading_line(color);
	handle_ctrl_d(*line, shell);
	if (!*line)
		return (1);
	return (0);
}

int	main7(char *line, t_cmd **cmds, t_shell *shell, int *color)
{
	int	ret;

	ret = main2(line, cmds, shell);
	if (ret != 0)
	{
		safe_free_cmds(*cmds);
		*cmds = NULL;
		return (0);
	}
	ret = main3(cmds, shell);
	if (ret != 0)
		return (ret);
	ret = main4(cmds, shell);
	if (ret != 0)
		return (ret);
	(*color)++;
	main5(cmds, shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_main.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 20:53:02 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 23:36:59 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_special_char(char *str, int i, t_arg **current_args)
{
	if (str[i] == '\'')
		return (save_it_single_quoted(str, i, current_args) + 1);
	if (str[i] == '"')
		return (save_it_double_quoted(str, i, current_args) + 1);
	else if (str[i] == '>')
		return (save_it_redir_right(str, i, current_args) + 1);
	else if (str[i] == '<')
		return (save_it_redir_left(str, i, current_args) + 1);
	else
		return (save_it_word(str, i, current_args) + 1);
}

int	parse_one_command(char *str, int i, t_arg **current_args, t_cmd **cmds)
{
	while (str[i] && str[i] != '|')
	{
		if (str[i] == ' ' || str[i] == '\t')
			i++;
		else
		{
			i = handle_special_char(str, i, current_args);
			if (i == -1)
				return (ft_printf("Odd number of quotes\n"), -1);
		}
	}
	add_command(cmds, current_args);
	return (i);
}

int	parse_it_3(char *str, t_cmd **cmds, int *i, t_arg **current_args)
{
	t_arg	*pipe_arg;

	*current_args = NULL;
	if (str[*i + 1] == '|')
	{
		pipe_arg = create_arg("more-than_one_pipe", "error");
		if (!pipe_arg)
			return (-1);
		add_arg(current_args, pipe_arg);
		add_command(cmds, current_args);
		while (str[*i] == '|')
			(*i)++;
	}
	else
	{
		pipe_arg = create_arg("|", "pipe");
		if (!pipe_arg)
			return (-1);
		add_arg(current_args, pipe_arg);
		add_command(cmds, current_args);
		(*i)++;
	}
	return (0);
}

int	parse_it_2(char *str, t_cmd **cmds, int i, t_arg **current_args)
{
	while (str[i])
	{
		i = parse_one_command(str, i, current_args, cmds);
		if (i == -1)
			return (-1);
		if (str[i] == '|')
		{
			parse_it_3(str, cmds, &i, current_args);
		}
	}
	return (0);
}

int	parse_it(char *str, t_cmd **cmds)
{
	t_arg	*current_args;
	int		i;
	int		ret;

	current_args = NULL;
	i = 0;
	if (precheck(str) == 1)
		return (ft_printf("Error with parentheses\n"), -1);
	if (precheck(str) == 2)
		return (ft_printf("Error with pipe position\n"), -1);
	if (precheck(str) == 3)
		return (ft_printf("Incorrect filename\n"), -1);
	ret = parse_it_2(str, cmds, i, &current_args);
	if (current_args)
		free_args(current_args);
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_save_it.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 20:53:29 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 19:07:54 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	save_it_word(char *str, int i, t_arg **args)
{
	int		j;
	char	*to_save;
	t_arg	*new_arg;

	j = i;
	while (str[j] && !ft_strchr(" ><'\"", str[j]))
		j++;
	to_save = ft_substr(str, i, j - i);
	if (!to_save)
		return (-1);
	new_arg = create_arg(to_save, "word");
	free(to_save);
	if (!new_arg)
		return (-1);
	add_arg(args, new_arg);
	return (j - 1);
}

int	save_it_double_quoted(char *str, int i, t_arg **args)
{
	int		j;
	t_arg	*arg;
	char	*to_save;

	j = i + 1;
	while (str[j] && (str[j] != '"'))
		j++;
	if (!str[j])
		return (-2);
	to_save = ft_substr(str, i + 1, j - i - 1);
	if (!to_save)
		return (-1);
	arg = create_arg(to_save, "double_quoted");
	free(to_save);
	if (!arg)
		return (-1);
	add_arg(args, arg);
	return (j);
}

int	save_it_single_quoted(char *str, int i, t_arg **args)
{
	int		j;
	t_arg	*arg;
	char	*to_save;

	j = i + 1;
	while (str[j] != '\0' && (str[j] != '\''))
		j++;
	if (str[j] == '\0')
		return (-2);
	to_save = ft_substr(str, i + 1, j - i - 1);
	arg = create_arg(to_save, "single_quoted");
	free(to_save);
	add_arg(args, arg);
	return (j);
}

int	save_it_redir_right(char *str, int i, t_arg **args)
{
	if (str[i] && str[i + 1] == '>')
	{
		add_arg(args, create_arg(">>", "double_redir_right"));
		return (i + 1);
	}
	else
	{
		add_arg(args, create_arg(">", "redir_right"));
		return (i);
	}
}

int	save_it_redir_left(char *str, int i, t_arg **args)
{
	if (str[i] && str[i + 1] == '<')
	{
		add_arg(args, create_arg("<<", "double_redir_left"));
		return (i + 1);
	}
	else
	{
		add_arg(args, create_arg("<", "redir_left"));
		return (i);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 02:33:25 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 23:48:06 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_arg	*create_arg(char *content, const char *type)
{
	t_arg	*new;

	(void)type;
	new = malloc(sizeof(t_arg));
	if (!new)
		return (NULL);
	new->content = ft_strdup(content);
	if (!new->content)
	{
		free(new);
		return (NULL);
	}
	if (ft_strcmp(type, "word") == 0 || ft_strcmp(type, "pipe") == 0
		|| ft_strcmp(type, "command") == 0 || ft_strcmp(type, "file") == 0
		|| ft_strcmp(type, "redir_right") == 0 || ft_strcmp(type,
			"redir_left") == 0 || ft_strcmp(type, "double_redir_right") == 0
		|| ft_strcmp(type, "double_redir_left") == 0 || ft_strcmp(type,
			"double_quoted") == 0 || ft_strcmp(type, "single_quoted") == 0)
		new->type = (char *)type;
	new->next = NULL;
	return (new);
}

void	add_arg(t_arg **head, t_arg *new_arg)
{
	t_arg	*current;

	if (!*head)
	{
		*head = new_arg;
	}
	else
	{
		current = *head;
		while (current->next)
		{
			current = current->next;
		}
		current->next = new_arg;
	}
}

void	add_command(t_cmd **cmds, t_arg **current_args)
{
	t_cmd	*new_cmd;
	t_cmd	*last_cmd;

	if (!cmds || !current_args || !*current_args)
		return ;
	new_cmd = malloc(sizeof(t_cmd));
	if (!new_cmd)
	{
		free_args(*current_args);
		*current_args = NULL;
		return ;
	}
	new_cmd->args = *current_args;
	new_cmd->next = NULL;
	if (!*cmds)
		*cmds = new_cmd;
	else
	{
		last_cmd = *cmds;
		while (last_cmd->next)
			last_cmd = last_cmd->next;
		last_cmd->next = new_cmd;
	}
	*current_args = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pre_check.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 21:25:51 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/28 18:19:10 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	check_pipe_position(char *input)
{
	int	i;

	if (!input || !*input)
		return (0);
	if (input[0] == '|')
		return (-1);
	i = 0;
	while (input[i])
	{
		if (input[i] == '|')
		{
			if (i == 0 || (input[i - 1] != ' ' && input[i - 1] != '\t'))
				return (-1);
			if (!input[i + 1])
				return (-1);
		}
		i++;
	}
	return (0);
}

int	precheck(char *input)
{
	if (check_pipe_position(input) == -1)
		return (2);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_filename.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 02:52:31 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:33:32 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_valid_char(char str)
{
	if (!((str >= 65 && str <= 90) || (str >= 97 && str <= 122) || (str >= 48
				&& str <= 57) || str == 95 || str == 46 || str == 45))
	{
		return (-1);
	}
	return (1);
}

int	check_file_name(char *input)
{
	int	i;

	i = 0;
	while (input[i])
	{
		if (is_valid_char(input[i]) == -1)
			return (-1);
		i++;
	}
	return (0);
}

int	error_in_filename(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	int		i;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			i = 0;
			if (ft_strncmp(current_arg->type, "file", 4) == 0)
			{
				if (check_file_name(current_arg->content) == -1)
					return (-1);
			}
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_parentheses.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 02:24:00 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 01:22:30 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	error_if_unclosed_parentheses2(int *open_parentheses, t_arg *current_arg)
{
	int	i;

	i = 0;
	if (ft_strncmp(current_arg->type, "word", 4) == 0)
	{
		while (current_arg->content[i])
		{
			if (current_arg->content[i] == '(')
				open_parentheses++;
			else if (current_arg->content[i] == ')')
			{
				open_parentheses--;
				if (open_parentheses < 0)
					return (-1);
			}
			i++;
		}
	}
	return (0);
}

int	error_if_unclosed_parentheses(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	int		open_parentheses;

	open_parentheses = 0;
	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (error_if_unclosed_parentheses2(&open_parentheses,
					current_arg) == -1)
				return (-1);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
	if (open_parentheses != 0)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_expansion2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 01:53:59 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 02:02:09 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_valid_char_for_env(char c)
{
	if (c == '_')
		return (1);
	if (c >= 'a' && c <= 'z')
		return (1);
	if (c >= 'A' && c <= 'Z')
		return (1);
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}

void	handle_exit_status_for_env(t_arg *current_arg, int *i, t_shell shell)
{
	char	*status_str;
	int		start;

	start = *i + 1;
	status_str = ft_itoa(shell.last_exit_status);
	if (!status_str)
		return ;
	replace_env_var(current_arg, *i, start + 1, status_str);
	*i += ft_strlen(status_str) - 1;
	free(status_str);
}

int	get_var_name_end_env(const char *content, int start)
{
	int	j;

	j = start;
	while (content[j] && is_valid_char_for_env(content[j]))
		j++;
	return (j);
}

void	replace_env_var(t_arg *current_arg, int start, int end,
		const char *value)
{
	size_t	old_len;
	size_t	val_len;
	size_t	new_len;
	char	*new_str;

	old_len = ft_strlen(current_arg->content);
	val_len = ft_strlen(value);
	new_len = old_len - (end - start) + val_len;
	new_str = malloc(new_len + 1);
	if (!new_str)
		return ;
	ft_strlcpy(new_str, current_arg->content, start + 1);
	ft_strlcpy(new_str + start, value, val_len + 1);
	ft_strlcpy(new_str + start + val_len, current_arg->content + end, old_len
		- end + 1);
	free(current_arg->content);
	current_arg->content = new_str;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_expansion.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 14:20:04 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 23:34:09 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	process_standard_var_env(t_arg *current_arg, int *i, int start)
{
	char		var_name[512];
	const char	*env_value;
	int			j;

	if (!current_arg->content[start] || current_arg->content[start] == ' ')
	{
		current_arg->content[*i] = '$';
		*i = start;
		return ;
	}
	j = get_var_name_end_env(current_arg->content, start);
	if (j == start)
	{
		*i = start;
		return ;
	}
	ft_strlcpy(var_name, current_arg->content + start, j - start + 1);
	env_value = getenv(var_name);
	if (env_value)
	{
		replace_env_var(current_arg, *i, j, env_value);
		*i += ft_strlen(env_value) - 1;
	}
	else
		*i = j - 1;
}

void	process_env_var(t_arg *current_arg, int *i, t_shell shell)
{
	int	start;

	start = *i + 1;
	if (!current_arg->content[start])
	{
		*i = start;
		return ;
	}
	if (current_arg->content[start] == '?')
	{
		handle_exit_status_for_env(current_arg, i, shell);
		return ;
	}
	process_standard_var_env(current_arg, i, start);
}

void	expand_env_vars(t_arg *current_arg, t_shell shell)
{
	int	i;

	i = 0;
	if (!current_arg->content)
		return ;
	while (current_arg->content[i])
	{
		if (current_arg->content[i] == '$' && (!current_arg->content[i + 1]
				|| current_arg->content[i + 1] == ' '))
		{
			i++;
			continue ;
		}
		else if (current_arg->content[i] == '$' && current_arg->content[i + 1]
			&& (current_arg->content[i + 1] == '?' || current_arg->content[i
					+ 1] == '_' || ft_isalnum(current_arg->content[i + 1])))
		{
			process_env_var(current_arg, &i, shell);
		}
		else
			i++;
	}
}

void	expand_env_vars_in_cmds_tab(t_cmd **cmds, t_shell shell)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (ft_strncmp(current_arg->type, "word", 4) == 0
				|| ft_strncmp(current_arg->type, "double_quoted", 13) == 0)
				expand_env_vars(current_arg, shell);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   replace_exit_status.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 02:09:57 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 23:46:18 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	process_exit_status(t_arg *current_arg, int *i, t_shell *shell)
{
	char	*status_str;
	char	*new_str;
	size_t	old_len;
	size_t	new_len;

	status_str = ft_itoa(shell->exit_status);
	if (!status_str)
		return ;
	old_len = ft_strlen(current_arg->content);
	new_len = old_len - 2 + ft_strlen(status_str);
	new_str = malloc(new_len + 1);
	if (!new_str)
	{
		free(status_str);
		return ;
	}
	ft_strlcpy(new_str, current_arg->content, *i + 1);
	ft_strlcpy(new_str + *i, status_str, ft_strlen(status_str) + 1);
	ft_strlcpy(new_str + *i + ft_strlen(status_str), current_arg->content + *i
		+ 2, old_len - *i - 1);
	*i += ft_strlen(status_str) - 1;
	free(current_arg->content);
	free(status_str);
	current_arg->content = new_str;
}

void	replace_exit_status(t_arg *current_arg, t_shell *shell)
{
	int	i;

	if (!current_arg->content)
		return ;
	i = 0;
	while (current_arg->content && current_arg->content[i])
	{
		if (current_arg->content[i] == '$')
		{
			if (!current_arg->content[i + 1] || current_arg->content[i
					+ 1] != '?')
			{
				i++;
				continue ;
			}
			process_exit_status(current_arg, &i, shell);
		}
		else
			i++;
	}
}

void	replace_exit_status_in_cmds_tab(t_cmd **cmds, t_shell *shell)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (ft_strncmp(current_arg->type, "word", 4) == 0
				|| ft_strncmp(current_arg->type, "double_quoted", 13) == 0)
				replace_exit_status(current_arg, shell);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   subsequent.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 01:06:59 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:33:55 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_redirect_or_pipe(char *type)
{
	return (ft_strncmp(type, "pipe", 4) == 0 || ft_strncmp(type, "redir_left",
			10) == 0 || ft_strncmp(type, "redir_right", 11) == 0
		|| ft_strncmp(type, "double_redir_left", 16) == 0 || ft_strncmp(type,
			"double_redir_right", 17) == 0);
}

int	error_if_subsequent_commands(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	t_arg	*next_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg && current_arg->next)
		{
			next_arg = current_arg->next;
			if (is_redirect_or_pipe(current_arg->type)
				&& is_redirect_or_pipe(next_arg->type))
				return (-1);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   words_to_file.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 00:36:43 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 23:31:36 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	type_to_file_in_args1(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (ft_strncmp(current_arg->type, "redir_right", 11) == 0
				|| ft_strncmp(current_arg->type, "double_redir_right", 18) == 0
				|| ft_strncmp(current_arg->type, "redir_left", 10) == 0
				|| ft_strncmp(current_arg->type, "double_redir_left", 17) == 0)
			{
				if (current_arg->next)
					current_arg->next->type = "file";
			}
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals2.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 23:38:24 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:38:50 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_ctrl_d(char *line, t_shell *shell)
{
	int	exit_status;

	exit_status = shell->last_exit_status;
	if (!line)
	{
		if (shell)
			clean_all(shell);
		write(1, "exit\n", 5);
		exit(exit_status);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 13:24:52 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/30 23:44:13 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	sigint_handler(int signum)
{
	if (g_received_signal == 10)
	{
		write(1, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 1);
	}
	else
	{
		write(1, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 1);
		rl_redisplay();
	}
	g_received_signal = signum;
}

void	setup_readline_signals(void)
{
	rl_catch_signals = 0;
	rl_catch_sigwinch = 1;
	signal(SIGINT, sigint_handler);
}

void	sigquit_handler(int signum)
{
	(void)signum;
	write(1, "Quit: 3\n", 8);
	exit(131);
}

void	setup_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = sigint_handler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sigaction(SIGINT, &sa, NULL);
	signal(SIGQUIT, SIG_IGN);
}

void	setup_child_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = SIG_DFL;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   count_cmds.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 19:03:54 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/27 19:06:34 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_cmd(t_cmd *cmd)
{
	int		nbr_cmd;
	t_arg	*arg;

	nbr_cmd = 0;
	while (cmd)
	{
		arg = cmd->args;
		while (arg)
		{
			if (ft_strcmp(arg->type, "command") == 0)
			{
				nbr_cmd++;
				break ;
			}
			arg = arg->next;
		}
		cmd = cmd->next;
	}
	return (nbr_cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cut_the_cmd_plus_arg.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 15:11:30 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:52:08 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_arguments_for_t_arg(t_arg *args)
{
	int	count;

	count = 0;
	while (args)
	{
		count++;
		args = args->next;
	}
	return (count);
}

// Including the cmd
int	how_many_args(t_arg *args)
{
	int	count;

	count = 0;
	while (args && ft_strcmp(args->type, "command") != 0)
		args = args->next;
	if (args == NULL)
		return (0);
	while (args && is_redir(args) == 0)
	{
		count++;
		args = args->next;
	}
	return (count);
}

int	fill_cmd_plus_args(t_arg **current, char **cmd_plus_args)
{
	int	i;

	i = 0;
	while (*current && is_redir(*current) == 0)
	{
		cmd_plus_args[i] = ft_strdup((*current)->content);
		if (!cmd_plus_args[i])
		{
			while (--i >= 0)
				free(cmd_plus_args[i]);
			return (-1);
		}
		i++;
		*current = (*current)->next;
	}
	cmd_plus_args[i] = NULL;
	return (0);
}

int	cut_the_cmd_plus_args(t_cmd *cmd)
{
	t_arg	*current;
	char	**cmd_plus_args;

	current = cmd->args;
	cmd_plus_args = malloc(sizeof(char *) * (how_many_args(current) + 1));
	if (!cmd_plus_args)
		return (-1);
	while (current && ft_strcmp(current->type, "command") != 0)
		current = current->next;
	if (!current)
	{
		free(cmd_plus_args);
		return (-1);
	}
	if (fill_cmd_plus_args(&current, cmd_plus_args) == -1)
	{
		free(cmd_plus_args);
		return (-1);
	}
	cmd->cmd_arg_stdin = cmd_plus_args;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   edit_args_for_export.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 11:37:44 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:25:33 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Carrement creer un nouveau t_arg ca sera plus simple.
// void	edit_args_for_export(t_arg *args)
// {
// 	while (args && args->next)
// 	{
// 		if (ft_strcmp(args->next->type, "double_quoted") == 0
// 			|| ft_strcmp(args->next->type, "single_quoted") == 0)
// 			args->content = ft_strjoin(args->content, args->next->content);
// 		args = args->next;
// 	}
// }

void	edit_args_for_export(t_arg *args)
{
	t_arg	*tmp;
	char	*new_content;

	while (args && args->next)
	{
		if (ft_strcmp(args->next->type, "double_quoted") == 0
			|| ft_strcmp(args->next->type, "single_quoted") == 0)
		{
			tmp = args->next;
			new_content = ft_strjoin(args->content, tmp->content);
			if (new_content)
			{
				free(args->content);
				args->content = new_content;
				args->next = tmp->next;
				free(tmp->content);
				free(tmp);
			}
			else
				args = args->next;
		}
		else
			args = args->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_add_add_type_cmd.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 11:34:35 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:58:57 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	find_arg_update_type(t_arg *tmp, t_shell *shell)
{
	char	*path;

	if (is_built_in_t_args(tmp) == 1)
		tmp->type = "command";
	else if (is_absolute_or_relative_path(tmp->content))
	{
		path = handle_paths(tmp->content);
		if (path != NULL)
		{
			tmp->type = "command";
			free(path);
		}
	}
	else
	{
		path = find_command_path(shell, tmp->content, shell->envp);
		if (path != NULL)
		{
			tmp->type = "command";
			free(path);
		}
		else if (path)
			free(path);
	}
}

void	find_arg_add_type_cmd(t_shell *shell, t_arg *args)
{
	t_arg	*tmp;

	tmp = args;
	while (tmp)
	{
		if (ft_strcmp(tmp->type, "file") == 0)
		{
			tmp = tmp->next;
			continue ;
		}
		find_arg_update_type(tmp, shell);
		tmp = tmp->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_getenv.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 06:36:41 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:27:23 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_getenv(char **env, char *name)
{
	int	i;
	int	j;

	i = 0;
	while (env[i])
	{
		j = 0;
		while (name[j] && env[i][j] && name[j] == env[i][j])
			j++;
		if (name[j] == '\0' && env[i][j] == '=')
			return (&env[i][j + 1]);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_real_cmd_in_cmds.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 07:09:10 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 07:09:54 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_real_cmd_in_cmds(t_cmd *cmds)
{
	t_arg	*arg;

	while (cmds)
	{
		arg = cmds->args;
		while (arg)
		{
			if (ft_strcmp(arg->type, "command") == 0)
				return (1);
			arg = arg->next;
		}
		cmds = cmds->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_redir.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 14:48:26 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/20 14:49:48 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_redir(t_arg *arg)
{
	if (ft_strcmp(arg->type, "redir_right") == 0)
		return (1);
	if (ft_strcmp(arg->type, "double_redir_right") == 0)
		return (1);
	if (ft_strcmp(arg->type, "redir_left") == 0)
		return (1);
	if (ft_strcmp(arg->type, "here_doc") == 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_init.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 13:38:17 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 13:38:42 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	**env_copy(char **env)
{
	int		i;
	char	**new_env;

	i = 0;
	while (env[i])
		i++;
	new_env = malloc(sizeof(char *) * (i + 1));
	if (!new_env)
		return (NULL);
	i = 0;
	while (env[i])
	{
		new_env[i] = ft_strdup(env[i]);
		if (!new_env[i])
		{
			while (i >= 0)
				free(new_env[i--]);
			return (NULL);
		}
		i++;
	}
	new_env[i] = NULL;
	return (new_env);
}

t_shell	*init_struct_shell(char **envp)
{
	t_shell	*shell;

	(void)envp;
	shell = ft_calloc(sizeof(t_shell), 1);
	if (!shell)
		return (NULL);
	shell->last_exit_status = 0;
	shell->envp = env_copy(envp);
	shell->cmds = NULL;
	shell->total_cmd_count = 0;
	shell->nbr_pipes = 0;
	shell->infile = 0;
	shell->outfile = 0;
	shell->input_pipe = 0;
	shell->there_is_redir_out = 0;
	shell->n_th_cmd = 0;
	shell->pipes = NULL;
	shell->child_pids = NULL;
	shell->in_child_process = 0;
	return (shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   other.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 13:26:41 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 13:27:07 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	str_arg_in_null(t_cmd *cmd)
{
	while (cmd)
	{
		cmd->cmd_arg_stdin = NULL;
		cmd = cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_counter.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 19:39:41 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/22 04:54:02 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_pipe(t_cmd *cmd)
{
	int	nbr_pipe;

	nbr_pipe = 0;
	while (cmd && ft_strcmp(cmd->args->type, "semicolon") != 0)
	{
		if (ft_strcmp(cmd->args->type, "pipe") == 0)
			nbr_pipe++;
		cmd = cmd->next;
	}
	return (nbr_pipe);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_args.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 20:00:37 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 03:15:14 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_args(t_arg *args)
{
	printf("[");
	while (args)
	{
		printf("content : '%s', type : '%s'", args->content, args->type);
		if (args->next)
			printf(", ");
		args = args->next;
	}
	printf("]");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   t_env_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 06:18:27 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/30 23:09:24 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*get_env_name(char *env_line)
{
	int		i;
	char	*name;
	int		j;

	i = 0;
	while (env_line[i] && env_line[i] != '=')
		i++;
	name = (char *)malloc(sizeof(char) * (i + 1));
	if (!name)
		return (NULL);
	j = 0;
	while (j < i)
	{
		name[j] = env_line[j];
		j++;
	}
	name[j] = '\0';
	return (name);
}

char	*get_env_value(char *env_line)
{
	int		i;
	char	*value;

	i = 0;
	while (env_line[i] && env_line[i] != '=')
		i++;
	if (env_line[i] == '\0')
		return (NULL);
	value = ft_strdup(env_line + i + 1);
	return (value);
}

t_env	*create_node(char *env_line)
{
	t_env	*node;

	node = (t_env *)malloc(sizeof(t_env));
	if (!node)
		return (NULL);
	node->line = ft_strdup(env_line);
	if (!node->line)
		return (free(node), NULL);
	node->name = get_env_name(env_line);
	if (!node->name)
		return (free(node->line), free(node), NULL);
	node->value = get_env_value(env_line);
	if (!node->value && ft_strchr(env_line, '=') != NULL)
		return (free(node->name), free(node->line), free(node), NULL);
	node->next = NULL;
	return (node);
}

t_env	*add_node(t_env *head, t_env *new_node)
{
	t_env	*current;

	if (!head)
		return (new_node);
	current = head;
	while (current->next)
		current = current->next;
	current->next = new_node;
	return (head);
}

t_env	*create_t_env(char **envp)
{
	t_env	*head;
	t_env	*new_node;
	int		i;

	head = NULL;
	i = 0;
	while (envp[i])
	{
		new_node = create_node(envp[i]);
		if (!new_node)
			return (NULL);
		head = add_node(head, new_node);
		i++;
	}
	return (head);
}
