# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    code                                               :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/10/06 02:55:26 by mblanc            #+#    #+#              #
#    Updated: 2024/10/29 20:06:24 by mblanc           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "minishell.h"

// Fonction pour exécuter la commande
static void	execute_command(t_shell *shell, t_cmd *cmd, char *path)
{
	if (execve(path, cmd->cmd_arg_stdin, shell->envp) == -1)
	{
		if (access(path, F_OK) == 0 && access(path, X_OK) != 0)
		{
			free(path);
			perror("execve error");
			exit(126);
		}
		free(path);
		perror("execve error");
		exit(127);
	}
}

// Fonction auxiliaire pour préparer l'exécution
static char	*prepare_execution(t_shell *shell, t_cmd *cmd)
{
	char	*path;

	if (!cmd || !cmd->args || !cmd->args->content)
	{
		perror("Command content is NULL");
		exit(127);
	}
	if (is_real_cmd_in_cmds(cmd) == 0 || !cmd->cmd_arg_stdin)
	{
		perror("No command found");
		exit(127);
	}
	path = find_command_path(shell, cmd->cmd_arg_stdin[0], shell->envp);
	if (!path)
	{
		perror("execve error");
		exit(shell->exit_status);
	}
	if (!cmd->cmd_arg_stdin)
	{
		perror("Command arguments are NULL");
		free(path);
		exit(127);
	}
	return (path);
}

// Fonction principale pour effectuer l'exécution
int	do_the_execution(t_shell *shell, t_cmd *cmd, char **envp)
{
	char	*path;

	(void)envp;
	path = prepare_execution(shell, cmd);
	execute_command(shell, cmd, path);
	// La fonction execve ne retourne pas si elle réussit
	free(path);
	return (0);
}

// Fonction pour exécuter une commande seule
int	execute_solo(t_shell *shell)
{
	pid_t	pid;
	int		status;

	status = -1;
	pid = fork();
	if (pid == -1)
	{
		error_msg("Fork failed\n");
		shell->exit_status = 1;
		return (-1);
	}
	if (pid == 0)
	{
		setup_child_signals();
		dup2(shell->infile, STDIN_FILENO);
		dup2(shell->outfile, STDOUT_FILENO);
		if (shell->infile > STDIN)
			close(shell->infile);
		if (shell->outfile > STDOUT)
			close(shell->outfile);
		if (do_the_execution(shell, shell->cmds, shell->envp) == -1)
			exit(1);
	}
	else
	{
		waitpid(pid, &status, 0);
		if (status == -1)
			return (0);
		if (WIFEXITED(status))
			shell->exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			shell->exit_status = 128 + WTERMSIG(status);
		else
			shell->exit_status = 1;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fonction_de_damien.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 06:04:18 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 06:34:07 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	expand_in_here_doc16(const char *str, size_t start)
{
    size_t len;

    len = 0;
    while (str[start + len] && ((str[start + len] >= 'A' && str[start + len] <= 'Z') || 
           (str[start + len] >= 'a' && str[start + len] <= 'z') || 
           (str[start + len] >= '0' && str[start + len] <= '9') || 
           str[start + len] == '_'))
        len++;
    return (len);
}

char *expand_in_here_doc15(const char *str, size_t start, size_t var_len)
{
    char *var_name;
    char *env_value;

    var_name = malloc(var_len + 1);
    if (!var_name)
        return (NULL);
    ft_memcpy(var_name, str + start, var_len);
    var_name[var_len] = '\0';
    env_value = getenv(var_name);
    free(var_name);
    return (env_value);
}

size_t expand_in_here_doc14(int n)
{
    size_t len;

    len = 1;
    if (n < 0)
        len++;
    while (n / 10)
    {
        len++;
        n /= 10;
    }
    return (len);
}

void expand_in_here_doc13(char *str, int n, size_t len)
{
    int digit;

    str[len] = '\0';
    if (n == 0)
    {
        str[0] = '0';
        return;
    }
    if (n < 0)
        str[0] = '-';
    while (n)
    {
        len--;
        digit = n % 10;
        if (digit < 0)
            digit = -digit;
        str[len] = digit + '0';
        n /= 10;
    }
}

char *expand_in_here_doc12(int n)
{
    char *result;
    size_t len;

    len = expand_in_here_doc14(n);
    result = malloc(len + 1);
    if (!result)
        return (NULL);
    expand_in_here_doc13(result, n, len);
    return (result);
}

size_t expand_in_here_doc11(int last_exit_status)
{
    char *exit_str;
    size_t len;

    exit_str = expand_in_here_doc12(last_exit_status);
    if (!exit_str)
        return (0);
    len = ft_strlen(exit_str);
    free(exit_str);
    return (len);
}

size_t expand_in_here_doc10(const char *str, size_t start, size_t var_len)
{
    char *env_value;
    size_t len;

    env_value = expand_in_here_doc15(str, start, var_len);
    if (!env_value)
        return (0);
    len = ft_strlen(env_value);
    return (len);
}

size_t expand_in_here_doc9(const char *str, size_t *i, int last_exit_status)
{
    size_t new_len;
    size_t var_len;

    new_len = 0;
    if (str[*i + 1] == '?') {
        new_len = expand_in_here_doc11(last_exit_status);
        *i += 2;
    } else {
        var_len = expand_in_here_doc16(str, *i + 1);
        if (var_len) {
            new_len = expand_in_here_doc10(str, *i + 1, var_len);
            *i += var_len + 1;
        } else {
            new_len = 1;
            (*i)++;
        }
    }
    return (new_len);
}

size_t expand_in_here_doc8(const char *str, int last_exit_status)
{
    size_t i;
    size_t new_len;
    size_t len;

    i = 0;
    new_len = 0;
    len = ft_strlen(str);
    while (i < len) {
        if (str[i] == '$' && str[i + 1])
            new_len += expand_in_here_doc9(str, &i, last_exit_status);
        else {
            new_len++;
            i++;
        }
    }
    return (new_len);
}

void expand_in_here_doc7(char *new_str, size_t *new_i, size_t *i, int last_exit_status)
{
    char *exit_str;
    size_t len;

    exit_str = expand_in_here_doc12(last_exit_status);
    if (!exit_str)
        return;
    len = ft_strlen(exit_str);
    ft_strlcpy(new_str + *new_i, exit_str, len + 1);
    *new_i += len;
    *i += 2;
    free(exit_str);
}

int expand_in_here_doc6(char *new_str, size_t *new_i, size_t *i, const char *str)
{
    size_t var_len;
    char *env_value;
    size_t len;

    var_len = expand_in_here_doc16(str, *i + 1);
    if (!var_len)
        return (0);
    env_value = expand_in_here_doc15(str, *i + 1, var_len);
    if (env_value) {
        len = ft_strlen(env_value);
        ft_strlcpy(new_str + *new_i, env_value, len + 1);
        *new_i += len;
    }
    *i += var_len + 1;
    return (1);
}

char *expand_in_here_doc5(const char *str, int last_exit_status)
{
    size_t len;
    size_t new_len;
    char *new_str;
    size_t i;
    size_t new_i;

    if (!str)
        return (NULL);
    len = ft_strlen(str);
    new_len = expand_in_here_doc8(str, last_exit_status);
    new_str = malloc(new_len + 1);
    if (!new_str)
        return (NULL);
    i = 0;
    new_i = 0;
    while (i < len) {
        if (str[i] == '$' && str[i + 1]) {
            if (str[i + 1] == '?')
                expand_in_here_doc7(new_str, &new_i, &i, last_exit_status);
            else if (!expand_in_here_doc6(new_str, &new_i, &i, str))
                new_str[new_i++] = str[i++];
        } else
            new_str[new_i++] = str[i++];
    }
    new_str[new_i] = '\0';
    return (new_str);
}

void expand_in_here_doc4(char **array)
{
    size_t i;

    i = 0;
    while (array[i])
        free(array[i++]);
    free(array);
}

size_t expand_in_here_doc2(char **array)
{
    size_t size;

    size = 0;
    while (array[size])
        size++;
    return (size);
}

char **expand_in_here_doc(char **array, int last_exit_status)
{
    size_t size;
    char **new_array;
    size_t i;

    if (!array)
        return (NULL);
    size = expand_in_here_doc2(array);
    new_array = malloc(sizeof(char *) * (size + 1));
    if (!new_array)
        return (NULL);
    i = 0;
    while (array[i]) {
        new_array[i] = expand_in_here_doc5(array[i], last_exit_status);
        if (!new_array[i])
		{
            while (i > 0)
                free(new_array[--i]);
            free(new_array);
            return (NULL);
        }
        i++;
    }
    new_array[i] = NULL;
    expand_in_here_doc4(array);
    return (new_array);
}

static char	**append_line(char **array, char *line, int size)
{
	char	**new_array;
	int		i;

	new_array = (char **)malloc(sizeof(char *) * (size + 2));
	if (!new_array)
		return (NULL);
	i = 0;
	while (i < size)
	{
		new_array[i] = array[i];
		i++;
	}
	new_array[i] = line;
	new_array[i + 1] = NULL;
	free(array);
	return (new_array);
}

static char	**read_file_to_array(int fd)
{
	char	**array;
	char	*line;
	int		size;

	array = NULL;
	size = 0;
	while ((line = get_next_line(fd)) != NULL)
	{
		array = append_line(array, line, size);
		if (!array)
		{
			free(line);
			return (NULL);
		}
		size++;
	}
	return (array);
}

static void	free_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

static int	write_array_to_file(int fd, char **array)
{
	int		i;
	ssize_t	wr;

	i = 0;
	while (array[i])
	{
		wr = write(fd, array[i], ft_strlen(array[i]));
		if (wr == -1)
			return (-1);
		wr = write(fd, "\n", 1);
		if (wr == -1)
			return (-1);
		i++;
	}
	return (0);
}

int	expand_in_here_doc25(char *file_name, int last_exit_status)
{
	int		fd;
	char	**array;
	char	**new_array;
	int		ret;

	fd = open(file_name, O_RDONLY);
	if (fd == -1)
		return (-1);
	array = read_file_to_array(fd);
	close(fd);
	if (!array)
		return (-1);
	new_array = expand_in_here_doc(array, last_exit_status);
	if (!new_array)
	{
		free_array(array);
		return (-1);
	}
	free_array(array);
	fd = open(file_name, O_WRONLY | O_TRUNC);
	if (fd == -1)
	{
		free_array(new_array);
		return (-1);
	}
	ret = write_array_to_file(fd, new_array);
	close(fd);
	free_array(new_array);
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_pipe_without_out_redirection.c              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 18:41:49 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 05:45:43 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int setup_pipe_redirections(t_shell *shell)
{
	// Première commande
	if (shell->n_th_cmd == 0)
	{
		if (shell->there_is_redir_in == 0)
		{
			if (dup2(shell->infile, STDIN_FILENO) == -1)
				return (-1);
		}
		if (shell->there_is_redir_out == 0)
		{
			if (dup2(shell->pipes[shell->n_th_cmd][1], STDOUT_FILENO) == -1)
				return (-1);
		}
	}
	// Dernière commande
	else if (shell->n_th_cmd == shell->total_cmd_count - 1)
	{
		if (shell->there_is_redir_in == 0)
		{
			if (dup2(shell->pipes[shell->n_th_cmd - 1][0], STDIN_FILENO) == -1)
				return (-1);
		}
		if (shell->there_is_redir_out == 0)
		{
			if (dup2(shell->outfile, STDOUT_FILENO) == -1)
				return (-1);
		}
			
	}
	// Commandes intermédiaires
	else
	{
		if (shell->there_is_redir_in == 0)
		{
			if (dup2(shell->pipes[shell->n_th_cmd - 1][0], STDIN_FILENO) == -1)
				return (-1);
		}
		if (shell->there_is_redir_out == 0)
		{
			if (dup2(shell->pipes[shell->n_th_cmd][1], STDOUT_FILENO) == -1)
				return (-1);
		}
	}	
	return (0);
}


// return 1 if a pipe is coming, 0 otherwise
int	handle_pipe_without_out_redirection(t_shell *shell)
{
	t_cmd *cmd;

	cmd = shell->cmds;
	// print_all_commands(shell->cmds);
	setup_pipe_redirections(shell);
	close_pipes(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_everything.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 03:06:09 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 01:30:18 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	clean_up_for_error_init(t_shell *shell, int pipe_count)
{
	int	i;

	if (shell->pipes)
	{
		i = 0;
		while (i < pipe_count)
		{
			if (shell->pipes[i])
				free(shell->pipes[i]);
			i++;
		}
		free(shell->pipes);
		shell->pipes = NULL;
	}
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
}

int	init_pipes(t_shell *shell)
{
	int	i;

	// Vérifier si le nombre de pipes est supérieur à 0
	if (shell->nbr_pipes <= 0)
	{
		shell->pipes = NULL;
		return (0);
	}
	shell->pipes = malloc(sizeof(int *) * shell->nbr_pipes);
	if (!shell->pipes)
		return (error_msg("Memory allocation failed\n"), -1);
	i = 0;
	while (i < shell->nbr_pipes)
	{
		shell->pipes[i] = malloc(2 * sizeof(int));
		if (!shell->pipes[i])
		{
			clean_up_for_error_init(shell, i);
			// Nettoyer les pipes alloués partiellement
			return (error_msg("Memory allocation failed\n"), -1);
		}
		if (pipe(shell->pipes[i]) == -1)
		{
			clean_up_for_error_init(shell, i);
			// Nettoyer les pipes alloués partiellement
			return (error_msg("Pipe creation failed\n"), -1);
		}
		i++;
	}
	return (0);
}

int	init_child_pids(t_shell *shell)
{
	if (shell->total_cmd_count <= 0)
	{
		shell->child_pids = NULL;
		return (0);
	}
	shell->child_pids = malloc(sizeof(pid_t) * shell->total_cmd_count);
	if (!shell->child_pids)
	{
		clean_up_for_error_init(shell, shell->nbr_pipes);
		return (error_msg("Memory allocation failed\n"), -1);
	}
	return (0);
}

void	initiates_type_cmd(t_shell *shell)
{
	int		i;
	t_cmd	*tmp;

	i = 0;
	if (shell == NULL)
		return ;
	tmp = shell->cmds;
	while (tmp)
	{
		find_arg_add_type_cmd(shell, tmp->args);
		tmp = tmp->next;
	}
}

int	all_init_for_pipes_cmds(t_shell *shell)
{
	if (shell->pipes)
	{
		free_pipes(shell->pipes, shell->nbr_pipes);
		shell->pipes = NULL;
	}
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
	shell->nbr_pipes = count_pipe(shell->cmds);
	shell->total_cmd_count = shell->nbr_pipes + 1;
	shell->there_is_redir_out = 0;
	shell->n_th_cmd = 0;
	if (init_pipes(shell) == -1)
	{
		clean_up_for_error_init(shell, 0);
		return (-1);
	}
	if (init_child_pids(shell) == -1)
	{
		clean_up_for_error_init(shell, shell->nbr_pipes);
		return (-1);
	}
	initiates_type_cmd(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 22:32:29 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/28 19:56:26 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fonction auxiliaire pour créer le chemin complet de la commande
static char *create_command_path(char *path, char *command)
{
    char *temp;
    char *full_path;

    if (path == NULL)
        return (NULL);
    if (path[strlen(path) - 1] != '/')
    {
        temp = ft_strjoin(path, "/");
        if (!temp)
            return (NULL);
    }
    else
    {
        temp = ft_strdup(path);
    }
    if (!temp)
        return (NULL);
    full_path = ft_strjoin(temp, command);
    free(temp); // Free temp after use
    return (full_path);
}

// Fonction auxiliaire pour vérifier l'accès au chemin de la commande
static char *verify_command_access(t_shell *shell, char *path, char *command)
{
    char *command_path;

    if (!path)
    {
        shell->exit_status = 127;
        return (NULL);
    }
    command_path = create_command_path(path, command);
    if (!command_path)
    {
        free(path);
        shell->exit_status = 12;
        return (NULL);
    }
    if (access(command_path, X_OK) == 0)
    {
        free(path);
        return (command_path);
    }
    if (access(command_path, F_OK) == 0)
        shell->exit_status = 126;
    else
        shell->exit_status = 127;
    free(command_path);
    free(path); // Ensure path is freed in all cases
    return (NULL);
}


// Nouvelle fonction pour rechercher la commande dans PATH
static char	*search_in_path(t_shell *shell, char *command, char **paths)
{
	int		i;
	char	*command_path;

	i = 0;
	while (paths[i] != NULL)
	{
		command_path = verify_command_access(shell, ft_strdup(paths[i]),
				command);
		if (command_path)
		{
			safe_free_all_strings(&paths);
			return (command_path);
		}
		i++;
	}
	return (NULL);
}

// Fonction pour trouver le chemin de la commande
char	*get_path_from_env(t_shell *shell, char *command, char **envp)
{
	char	**paths;
	char	*command_path;
	int		i;

	i = 0;
	while (envp[i] != NULL && ft_strncmp(envp[i], "PATH=", 5) != 0)
		i++;
	if (!envp[i])
	{
		shell->exit_status = 127;
		return (NULL);
	}
	paths = ft_split(envp[i] + 5, ':');
	if (paths == NULL)
	{
		shell->exit_status = 12;
		return (NULL);
	}
	command_path = search_in_path(shell, command, paths);
	if (command_path)
		return (command_path);
	safe_free_all_strings(&paths);
	shell->exit_status = 127;
	return (NULL);
}

char	*find_command_path(t_shell *shell, char *command, char **envp)
{
	if (!command || *command == '\0' || ft_str_is_whitespace(command) || envp == NULL)
	{
		shell->exit_status = 127;
		return (NULL);
	}
	if (is_absolute_or_relative_path(command))
	{
		if (access(command, F_OK) == 0 && access(command, X_OK) != 0)
		{
			shell->exit_status = 126;
			return (NULL);
		}
		if (access(command, X_OK) == 0)
			return (ft_strdup(command));
		shell->exit_status = 127;
		return (NULL);
	}
	return (get_path_from_env(shell, command, envp));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_process.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 22:14:46 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 05:52:36 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	parent_process(t_shell *shell, pid_t pid)
{
	if (shell->infile > STDIN)
		close(shell->infile);
	if (shell->outfile > STDOUT)
		close(shell->outfile);
	shell->child_pids[shell->n_th_cmd] = pid;
	return (0);
}

void close_pipes(t_shell *shell)
{
	int i;

	i = 0;
	while (i < shell->total_cmd_count - 1)
	{
		close(shell->pipes[i][0]);
		close(shell->pipes[i][1]);
		i++;
	}
}

void	child_process(t_shell *shell)
{
	setup_child_signals();
	handle_io_redirections(shell);
	if (shell->there_is_redir_out < 0)
	{
		error_msg("Error setup redirection\n");
		exit(EXIT_FAILURE);
	}
	cut_the_cmd_plus_args(shell->cmds);
	if (shell->there_is_redir_out)
		dup2(shell->outfile, STDOUT_FILENO);
	if (shell->there_is_redir_in)
		dup2(shell->infile, STDIN_FILENO);
	handle_pipe_without_out_redirection(shell);
	close_pipes(shell);
	if (shell->infile > STDIN)
		close(shell->infile);
	if (shell->outfile > STDOUT)
		close(shell->outfile);
	if (do_the_execution(shell, shell->cmds, shell->envp) == -1)
			exit(1);
}

int	advance_to_next_command(t_shell *shell)
{
	if (shell->cmds->args)
	{
		while (shell->cmds && ft_strcmp(shell->cmds->args->type, "pipe") != 0)
			shell->cmds = shell->cmds->next;
		if (shell->cmds)
			shell->cmds = shell->cmds->next;
	}
	else
		return (-1);
	return (0);
}

int	pipes_process(t_shell *shell)
{
	pid_t	pid;

	shell->infile = dup(STDIN);
	shell->outfile = dup(STDOUT);
	while (shell->cmds)
	{
		pid = fork();
		if (pid == -1)
			return (error_msg("Fork failed\n"), -1);
		if (pid == 0)
		{
			child_process(shell);
		}
		else
			parent_process(shell, pid);
		shell->n_th_cmd++;
		if (advance_to_next_command(shell) == -1)
			break;
		if (is_a_here_doc_in_the_cmd(shell->cmds))
			shell->nth_here_doc++;
		ft_printf("fin de la boucle\n");
	}
	close_pipes(shell);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_io_redirections.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 06:35:42 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 05:41:19 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_arg	*last_redir_left(t_arg *args)
{
	t_arg	*last_redir_left;

	last_redir_left = NULL;
	while (args)
	{
		if (ft_strcmp(args->type, "redir_left") == 0)
			last_redir_left = args;
		if (ft_strcmp(args->type, "double_redir_left") == 0)
			last_redir_left = args;
		args = args->next;
	}
	return (last_redir_left);
}

t_arg	*last_redir_right(t_arg *args)
{
	t_arg	*last_redir_right;

	last_redir_right = NULL;
	while (args)
	{
		if (ft_strcmp(args->type, "redir_right") == 0)
			last_redir_right = args;
		if (ft_strcmp(args->type, "double_redir_right") == 0)
			last_redir_right = args;
		args = args->next;
	}
	return (last_redir_right);
}

static int	handle_input_redirection(t_shell *shell, t_arg *redir_left)
{
	char	*name_file;

	if (redir_left != NULL)
	{
		if (ft_strcmp(redir_left->type, "double_redir_left") == 0)
		{
			name_file = name_files_here_doc(shell->nth_here_doc);
			shell->infile = open(name_file, O_RDONLY);
		}
		else
			shell->infile = open(redir_left->next->content, O_RDONLY);
		if (shell->infile < 0)
		{
			shell->exit_status = 1;
			error_msg("Failed to open infile\n");
			return (-1);
		}
	}
	else
	{
		shell->infile = STDIN_FILENO;
	}
	return (0);
}

static int	handle_output_redirection(t_shell *shell, t_arg *redir_right)
{
	if (redir_right != NULL)
	{
		if (ft_strcmp(redir_right->type, "redir_right") == 0)
			shell->outfile = open(redir_right->next->content,
								  O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (ft_strcmp(redir_right->type, "double_redir_right") == 0)
			shell->outfile = open(redir_right->next->content,
								  O_WRONLY | O_CREAT | O_APPEND, 0644);
		if (shell->outfile < 0)
		{
			shell->exit_status = 1;
			error_msg("Failed to open outfile\n");
			return (-1);
		}
	}
	else
	{
		shell->outfile = STDOUT_FILENO;
	}
	return (0);
}

int	handle_io_redirections(t_shell *shell)
{
	t_arg	*redir_left;
	t_arg	*redir_right;

	// print_all_commands(shell->cmds);
	redir_left = last_redir_left(shell->cmds->args);
	redir_right = last_redir_right(shell->cmds->args);
	if (handle_input_redirection(shell, redir_left) == -1)
		return (-1);
	if (handle_output_redirection(shell, redir_right) == -1)
	{
		if (redir_left != NULL && shell->infile != STDIN_FILENO)
			close(shell->infile);
		return (-1);
	}
	if (redir_left != NULL)
		shell->there_is_redir_in = 1;
	if (redir_right != NULL)
		shell->there_is_redir_out = 1;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   here_doc_management.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/08 04:54:57 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 06:35:57 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	write_to_temp(int fd, char *line)
{
	if (write(fd, line, ft_strlen(line)) == -1)
		return (error_msg("Problem writing to temp.txt"),
			free(line), close(fd), -1);
	if (write(fd, "\n", 1) == -1)
		return (error_msg("Problem writing newline to temp.txt"),
			free(line), close(fd), -1);
	return (0);
}

int	here_doc_management(char *limiter, char *name_file)
{
	int		fd;
	char	*line;
	size_t	len;

	fd = open(name_file, O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
		return (error_msg("Problem opening temp.txt"));
	while (1)
	{
		write(1, "> ", 2);
		line = get_next_line(0);
		if (!line)
			break ;
		len = ft_strlen(line);
		if (len > 0 && line[len - 1] == '\n')
			line[len - 1] = '\0';
		if (ft_strcmp(line, limiter) == 0 || len == 0)
			break ;
		if (write_to_temp(fd, line) == -1)
			return (-1);
		free(line);
	}
	free(line);
	close(fd);
	return (0);
}

int	delete_all_temp_files(int total_here_doc)
{
	int		i;
	char	*name_file;

	i = 0;
	while (i < total_here_doc)
	{
		name_file = name_files_here_doc(i);
		if (unlink(name_file) == -1)
			return (error_msg("Problem deleting temp.txt"), -1);
		free(name_file);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   name_files_here_doc.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 01:46:38 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 09:14:34 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_a_here_doc_in_the_cmd(t_cmd *cmd)
{
	t_arg *tmp;

	if (!cmd)
		return (0);
	tmp = cmd->args;
	while (tmp)
	{
		if (tmp)
		{
			if (ft_strcmp(tmp->type, "double_redir_left") == 0)
				return (1);
		}
		tmp = tmp->next;
	}
	return (0);
}

int count_here_doc_separated_by_pipes(t_cmd *cmd)
{
	int 	count;
	t_arg	*tmp;

	count = 0;
	while (cmd)
	{
		tmp = cmd->args;
		while (tmp)
		{
			if (tmp)
			{
				if (ft_strcmp(tmp->type, "double_redir_left") == 0)
				{
					count++;
					break;
				}
			}
			tmp = tmp->next;
		}
		cmd = cmd->next;
	}
	return (count);
}

t_arg	*verif_here_doc_and_find_limiter(t_arg *args)
{
	t_arg	*tmp;
	t_arg	*limiter;

	tmp = args;
	limiter = NULL;
	while (tmp)
	{
		if (ft_strcmp(tmp->type, "double_redir_left") == 0)
		{
			tmp = tmp->next;
			limiter = tmp;
		}
		tmp = tmp->next;
	}
	return (limiter);
}

int	handle_here_doc(t_shell *shell)
{
	int		i;
	int		total_here_doc;
	t_arg	*limiter;
	t_cmd	*cmds;

	i = 0;
	cmds = shell->cmds;
	total_here_doc = count_here_doc_separated_by_pipes(shell->cmds);
	while (i < total_here_doc)
	{
		limiter = verif_here_doc_and_find_limiter(cmds->args);
		if (!limiter)
			continue;
		if (here_doc_management(limiter->content, name_files_here_doc(i)) == -1)
			return (-1);
		if (cmds->next)
		{
			cmds = cmds->next;
		}
		while (is_a_here_doc_in_the_cmd(cmds) == 0)
			cmds = cmds->next;
		i++;
	}
	return (0);
}
// Will return the name of the temp file with the nbr
char	*name_files_here_doc(int nbr)
{
	char	*name;
	char	*nbr_str;

	nbr_str = ft_itoa(nbr);
	if (!nbr_str)
		return (NULL);
	name = ft_strjoin("temp", nbr_str);
	free(nbr_str);
	return (name);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   relative_absolute_path.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 11:11:50 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/28 21:27:10 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	**build_new_cmd(char *path, char **cmd, int args_count)
{
	char	**new_cmd;
	int		j;

	new_cmd = malloc(sizeof(char *) * (args_count + 2));
	if (!new_cmd)
		return (NULL);
	new_cmd[0] = ft_strdup("/bin/sh");
	new_cmd[1] = ft_strdup(path);
	j = 1;
	while (j < args_count)
	{
		new_cmd[j + 1] = ft_strdup(cmd[j]);
		j++;
	}
	new_cmd[args_count + 1] = NULL;
	return (new_cmd);
}

int	execute_with_shell(char *path, char **cmd, char **envp, int args_count)
{
	char	**new_cmd;
	int		j;

	new_cmd = build_new_cmd(path, cmd, args_count);
	if (!new_cmd)
	{
		perror("malloc error");
		exit(12);
	}
	execve("/bin/sh", new_cmd, envp);
	perror("execve error");
	j = 0;
	while (new_cmd[j])
	{
		free(new_cmd[j]);
		j++;
	}
	free(new_cmd);
	return (-1);
}

int	is_absolute_or_relative_path(char *command)
{
	if (!command)
		return (0);
	return (command[0] == '/' || (command[0] == '.' && command[1] == '/')
		|| (command[0] == '.' && command[1] == '.' && command[2] == '/'));
}

char	*handle_absolute_or_relative_path(char *command)
{
	if (access(command, X_OK) == 0)
		return (ft_strdup(command));
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   solo_cmd.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 21:22:35 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 10:24:48 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	single_cmd(t_shell *shell)
{
	t_arg	*current;

	current = shell->cmds->args;
	while (current && ft_strcmp(current->type, "command") != 0)
		current = current->next;
	if (!current)
		return (execute_solo(shell));
	if (is_built_in(shell->cmds->cmd_arg_stdin))
	{
		shell->exit_status = execute_built_in(shell, shell->cmds->cmd_arg_stdin,
				&shell->envp);
		ft_printf("TESTTT\n");
		return (shell->exit_status);
	}
	else
	{
		execute_solo(shell);
		if (shell->infile > STDIN)
			close(shell->infile);
		if (shell->outfile > STDOUT)
			close(shell->outfile);
		return (shell->exit_status);
	}
}

// Iniatiate all needed and call single_cmd to exec
int	starting_one_cmd(t_shell *shell)
{
	int	i;

	i = 0;
	if (shell == NULL || shell->cmds == NULL || shell->cmds->args == NULL)
		return (-1);
	if (handle_io_redirections(shell) == -1)
		return (-1);
	// Supprimer l'appel à all_init_for_pipes_cmds ici car il est déjà fait dans exec_it
	cut_the_cmd_plus_args(shell->cmds);
	if (single_cmd(shell) == -1)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_exec.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 23:04:23 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 09:14:45 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	any_empty_cmd(t_cmd *cmd)
{
	t_arg	*arg;

	while (cmd)
	{
		arg = cmd->args;
		if (arg == NULL)
			return (1);
		while (arg)
		{
			if (arg->content == NULL)
				return (1);
			arg = arg->next;
		}
		cmd = cmd->next;
	}
	return (0);
}

int	exec_it(t_shell *shell)
{
	if (shell == NULL || shell->cmds == NULL || shell->cmds->args == NULL || any_empty_cmd(shell->cmds))
		return (0);
	if (all_init_for_pipes_cmds(shell) == -1) // Un seul appel à all_init_for_pipes_cmds
		return (-1);
	if (count_cmd(shell->cmds) == 0)
		return (0);
	handle_here_doc(shell);
	if (shell->nbr_pipes == 0)
	{
		if (starting_one_cmd(shell) == -1)
		{
			clean_up_for_error_init(shell, shell->nbr_pipes);
			// Nettoyage en cas d'erreur
			return (-1);
		}
	}
	else if (shell->nbr_pipes >= 1)
	{
		pipes_process(shell);
		wait_and_cleanup(shell);
	}
	if (shell->nth_here_doc > 0)
		delete_all_temp_files(shell->nth_here_doc + 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wait_and_cleanup_pipes.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 02:49:55 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 01:32:19 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	wait_and_cleanup(t_shell *shell)
{
	int	i;
	int	status;

	i = 0;
	while (i < shell->total_cmd_count)
	{
		if (waitpid(shell->child_pids[i], &status, 0) == -1)
		{
			error_msg("Waitpid failed\n");
			shell->exit_status = 1;
		}
		else if (i == shell->total_cmd_count - 1)
		{
			if (WIFEXITED(status))
			{
				shell->exit_status = WEXITSTATUS(status);
			}
			else if (WIFSIGNALED(status))
			{
				shell->exit_status = 128 + WTERMSIG(status);
			}
		}
		i++;
	}
	cleanup(shell, NULL);
	if (shell->infile != -1)
		close(shell->infile);
	if (shell->outfile != -1)
		close(shell->outfile);
}


void	cleanup(t_shell *shell, char **cmd)
{
	int	i;

	i = 0;
	while (i < shell->nbr_pipes)
	{
		if (shell->pipes[i])
		{
			close(shell->pipes[i][0]);
			close(shell->pipes[i][1]);
			free(shell->pipes[i]);
		}
		i++;
	}
	free(shell->pipes);
	shell->pipes = NULL;
	if (shell->infile != -1)
		close(shell->infile);
	if (cmd)
		safe_free_all_strings(&cmd);
	if (shell->outfile != -1)
		close(shell->outfile);
	if (shell->child_pids)
	{
		ft_safe_free((void**)&(shell->child_pids));
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   doing_built_in.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 01:59:53 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 11:21:14 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_built_in(char **args)
{
	if (ft_strcmp(args[0], "echo") == 0)
		return (1);
	if (ft_strcmp(args[0], "cd") == 0)
		return (1);
	if (ft_strcmp(args[0], "pwd") == 0)
		return (1);
	if (ft_strcmp(args[0], "export") == 0)
		return (1);
	if (ft_strcmp(args[0], "env") == 0)
		return (1);
	if (ft_strcmp(args[0], "unset") == 0)
		return (1);
	if (ft_strcmp(args[0], "exit") == 0)
		return (1);
	return (0);
}

int	is_built_in_t_args(t_arg *args)
{
	if (ft_strcmp(args->content, "echo") == 0)
		return (1);
	if (ft_strcmp(args->content, "cd") == 0)
		return (1);
	if (ft_strcmp(args->content, "pwd") == 0)
		return (1);
	if (ft_strcmp(args->content, "export") == 0)
		return (1);
	if (ft_strcmp(args->content, "env") == 0)
		return (1);
	if (ft_strcmp(args->content, "unset") == 0)
		return (1);
	if (ft_strcmp(args->content, "exit") == 0)
		return (1);
	return (0);
}

int	execute_built_in(t_shell *shell, char **cmd_arg_stdin, char ***envp)
{
	if (ft_strcmp(cmd_arg_stdin[0], "echo") == 0)
		return (ft_echo(shell));
	if (ft_strcmp(cmd_arg_stdin[0], "cd") == 0)
		return (ft_cd(shell));
	if (ft_strcmp(cmd_arg_stdin[0], "pwd") == 0)
		return (ft_pwd(shell));
	if (ft_strcmp(cmd_arg_stdin[0], "export") == 0)
		return (ft_export(shell->cmds->args, envp)); 		// A bien faire a la fin
	if (ft_strcmp(cmd_arg_stdin[0], "env") == 0)
		return (ft_env(*envp, shell), 0);
	if (ft_strcmp(cmd_arg_stdin[0], "unset") == 0)			// A bien faire a la fin
		return (ft_unset(shell->cmds->args, envp), 0);
	if (ft_strcmp(cmd_arg_stdin[0], "exit") == 0)
		return (ft_exit(shell, shell->cmds->args));
	return (127);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 05:56:18 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 10:32:32 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
static int	go_last_place(t_shell *shell)
{
	char	*oldpwd;

	oldpwd = ft_getenv(shell->envp, "OLDPWD");
	if (!oldpwd)
	{
		error_msg("cd: OLDPWD not set\n");
		shell->exit_status = 1; // Erreur spécifique si OLDPWD n'est pas défini
		return (shell->exit_status);
	}
	if (chdir(oldpwd) == -1)
	{
		perror("cd");
		shell->exit_status = 1; // Erreur si chdir échoue
		return (shell->exit_status);
	}
	ft_printf("%s\n", oldpwd);
	return (0);
}

static int	go_home(t_shell *shell)
{
	char	*home;

	home = ft_getenv(shell->envp, "HOME");
	if (!home)
	{
		fprintf(stderr, "cd: HOME not set\n");
		shell->exit_status = 1; // Erreur spécifique si HOME n'est pas défini
		return (shell->exit_status);
	}
	if (chdir(home) == -1)
	{
		perror("cd");
		shell->exit_status = 1; // Erreur si chdir échoue
		return (shell->exit_status);
	}
	return (0);
}

int	ft_cd(t_shell *shell)
{
	char	**arg;
	char	*cwd;

	arg = shell->cmds->cmd_arg_stdin;
	if (arg == NULL || arg[0] == NULL)
        return (0);
	if (arg[1] != NULL && arg[2] != NULL)
	{
		error_msg("cd: too many arguments\n");
		shell->exit_status = 1; // Trop d'arguments
		return (shell->exit_status);
	}

	if (!arg[1])
	{
		if (go_home(shell) != 0)
			return (shell->exit_status);
	}
	else if (arg[1][0] == '-' && arg[1][1] == '\0')
	{
		if (go_last_place(shell) != 0)
			return (shell->exit_status);
	}
	else
	{
		if (chdir(arg[1]) == -1)
		{
			perror("cd");
			shell->exit_status = 1; // Erreur si chdir échoue
			return (shell->exit_status);
		}
	}

	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		perror("cd");
		shell->exit_status = 1;
		return (shell->exit_status);
	}

	setenv("OLDPWD", ft_getenv(shell->envp, "PWD"), 1);
	setenv("PWD", cwd, 1);
	free(cwd);
	shell->exit_status = 0;
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 22:35:19 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 10:20:19 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_flag_echo(char *flag)
{
	int	i;

	i = 1;
	if (flag == NULL)
		return (0);
	if (!(flag[0] == '-'))
		return (0);
	while (flag[i] && flag[i] == 'n')
		i++;
	if (flag[i] == '\0')
		return (1);
	return (0);
}

// Return 0 if iarg_stdin[1] is not a -n(n xtimes)
// Return x as the index of the first arg which is not a flag.
int	handle_multiple_n_echo(t_shell *shell)
{
	int	i;

	i = 1;
	while (shell->cmds->cmd_arg_stdin[i] != NULL)
	{
		if (!(is_flag_echo(shell->cmds->cmd_arg_stdin[i])))
			return (i);
		i++;
	}
	return (1);
}

int	ft_echo(t_shell *shell)
{
	int	no_newline;
	int	i;

	no_newline = 0;
	i = 1;
	if (!shell->cmds->cmd_arg_stdin[1])
		return (ft_putchar_fd('\n', shell->outfile), 0);
	i = handle_multiple_n_echo(shell);
	if (i > 1)
		no_newline = 1;
	ft_printf("i : %d\n", i);
	while (shell->cmds->cmd_arg_stdin[i] != NULL)
	{
		ft_putstr_fd(shell->cmds->cmd_arg_stdin[i], shell->outfile);
		if (shell->cmds->cmd_arg_stdin[i + 1] != NULL)
			ft_putchar_fd(' ', shell->outfile);
		i++;
	}
	if (!no_newline)
		ft_putchar_fd('\n', shell->outfile);
	return (0);
}

// int	ft_echo(t_shell *shell)
// {
// 	int	no_newline;
// 	int	i;

// 	no_newline = 0;
// 	i = 1;
// 	if (shell->cmds->cmd_arg_stdin[1] != NULL
// 		&& ft_strcmp(shell->cmds->cmd_arg_stdin[1], "-n") == 0) // piege quand en parametre -nnnnnnn
// 	{
// 		no_newline = 1;
// 		i = 2;
// 	}
// 	else
// 		i = 1;
// 	while (shell->cmds->cmd_arg_stdin[i] != NULL)
// 	{
// 		ft_putstr_fd(shell->cmds->cmd_arg_stdin[i], shell->outfile);
// 		if (shell->cmds->cmd_arg_stdin[i + 1] != NULL)
// 			ft_putchar_fd(' ', shell->outfile);
// 		i++;
// 	}
// 	if (!no_newline)
// 		ft_putchar_fd('\n', shell->outfile);
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:06:09 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/27 18:59:19 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_env(char **envp, t_shell *shell)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		ft_putstr_fd(envp[i], shell->outfile);
		ft_putchar_fd('\n', shell->outfile);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:07:45 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/20 21:05:11 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_numeric(char *str)
{
	int i;

	i = 0;
	if (!str)
		return (0);
	if (str[i] == '-' || str[i] == '+')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

int	ft_exit(t_shell *shell, t_arg *args)
{
	int exit_code;

	(void)shell;
	if (!shell->cmds->cmd_arg_stdin[1])
		exit(-1); // A terme utiliser le shell->last_exit_status
	args = args->next;
	if (!is_numeric(args->content))
	{
		ft_putstr_fd("exit: numeric argument required\n", STDERR_FILENO);
		exit(255);
	}
	if (args->next)
	{
		ft_putstr_fd("exit: too many arguments\n", STDERR_FILENO);
		return (1);
	}
	exit_code = ft_atoi(args->content);
	exit(exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 06:35:14 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 07:02:06 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	len_env(t_env *env)
{
	t_env	*current;
	int		len;

	len = 0;
	current = env;
	while (current)
	{
		len++;
		current = current->next;
	}
	return (len);
}

int	declare_and_sort(t_env *env)
{
	t_env	*current;
	t_env	*smallest;
	int		len;

	current = env;
    while (current)
	{
        current->declared = 0;
        current = current->next;
    }
	len = len_env(env);
	while (len-- > 0)
	{
		current = env;
		smallest = NULL;
		while (current)
		{
			if (current->declared == 0 && (smallest == NULL || ft_strcmp(current->name, smallest->name) < 0))
				smallest = current;
			current = current->next;
		}
		if (smallest)
		{
			smallest->declared = 1;
			ft_printf("declare -x %s=\"%s\"\n", smallest->name, smallest->value);
		}
	}
	return (0);
}

int	print_env(t_env *env)
{
	t_env	*current;

	current = env;
	while (current)
	{
		ft_printf("%s=%s\n", current->name, current->value);
		current = current->next;
	}
	return (0);
}

int	is_valid_identifier(char *str)
{
	int	i;

	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	i = 1;
	while (str[i] && str[i] != '=')
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

int	t_env_to_array(t_env *env, char ***envp)
{
	t_env	*current;
	int		i;

	*envp = malloc(sizeof(char *) * (len_env(env) + 1));
	if (!*envp)
		return (1);
	i = 0;
	current = env;
	while (current)
	{
		(*envp)[i] = ft_strdup(current->line);
		if (!(*envp)[i]) {
            while (i-- > 0)
                free((*envp)[i]);
            free(*envp);
            return (1);
        }
		i++;
		current = current->next;
	}
	(*envp)[i] = NULL;
	return (0);
}

t_env	*find_node_by_name(t_env *env, const char *name)
{
	t_env	*current;

	current = env;
	while (current)
	{
		if (ft_strcmp(current->name, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

char	*extract_name(const char *content)
{
	int		len;
	char	*name;
	int		i;

	len = 0;
	while (content[len] && content[len] != '=')
		len++;
	name = malloc(sizeof(char) * (len + 1));
	if (!name)
		return (NULL);
	i = 0;
	while (i < len)
	{
		name[i] = content[i];
		i++;
	}
	name[len] = '\0';
	return (name);
}


char	*extract_value(const char *content)
{
	char	*equal_sign;
	char	*value;

	equal_sign = ft_strchr(content, '=');
	if (!equal_sign)
		return (NULL);
	value = ft_strdup(equal_sign + 1);
	return (value);
}

int	ft_export(t_arg *args, char ***envp)
{
	t_env	*env;
	t_env	*existing_node;
	char	*name;
	char	*value;
	char	*temp_line;
	char	*temp;

	env = create_t_env(*envp);
	if (!env)
		return (1);
	if (count_arguments_for_t_arg(args) == 1)
		return (declare_and_sort(env), 0);
	args = args->next;
	edit_args_for_export(args);
	while (args)
	{
		if (is_valid_identifier(args->content) && ft_strchr(args->content, '='))
		{
			name = extract_name(args->content);
			value = extract_value(args->content);
			existing_node = find_node_by_name(env, name);
			if (existing_node)
			{
				free(existing_node->value);
				existing_node->value = ft_strdup(value);

				// Mettre à jour le champ line
				free(existing_node->line);
				temp_line = ft_strjoin(name, "=");
				if (!temp_line)
				{
					// Gérer l'erreur d'allocation
					free(name);
					free(value);
					return (1);
				}
				temp = ft_strjoin(temp_line, value);
				free(temp_line);
				if (!temp)
				{
					// Gérer l'erreur d'allocation
					free(name);
					free(value);
					return (1);
				}
				existing_node->line = temp;
			}
			else
			{
				env = add_node(env, create_node(args->content));
			}
			free(name);
			free(value);
		}
		else
			error_msg("export: not a valid identifier\n");
		args = args->next;
	}
	safe_free_all_strings(envp);
	if (t_env_to_array(env, envp) != 0)
		return (1);
	return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_pwd.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 05:55:10 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 10:23:40 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_pwd(t_shell *shell)
{
	char	cwd[PATH_MAX];

	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		ft_putstr_fd(cwd, shell->outfile);
		ft_putchar_fd('\n', shell->outfile);
	}
	else
		return (error_msg("pwd: error retrieving current directory\n"), 0);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 09:00:31 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/18 09:03:47 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_unset(t_arg *args, char ***env)
{
	int	j;
	size_t	len;

	args = args->next;
	while (args)
	{
		j = 0;
		len = ft_strlen(args->content);
		while ((*env)[j])
		{
			if (ft_strncmp((*env)[j], args->content, len) == 0 && (*env)[j][len] == '=')
			{
				free((*env)[j]);
				while ((*env)[j])
				{
					(*env)[j] = (*env)[j + 1];
					j++;
				}
				break;
			}
			j++;
		}
		args = args->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   reading_line.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 20:59:11 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 01:28:15 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	**init_colors(void)
{
	char	**colors;

	colors = malloc(sizeof(char *) * 15);
	if (!colors)
		return (NULL);
	colors[0] = BOLD_COLOR_BLUE;
	colors[1] = COLOR_RED;
	colors[2] = COLOR_GREEN;
	colors[3] = COLOR_YELLOW;
	colors[4] = COLOR_BLUE;
	colors[5] = COLOR_PURPLE;
	colors[6] = COLOR_CYAN;
	colors[7] = COLOR_WHITE;
	colors[8] = BOLD_COLOR_RED;
	colors[9] = BOLD_COLOR_GREEN;
	colors[10] = BOLD_COLOR_YELLOW;
	colors[11] = COLOR_BLACK;
	colors[12] = BOLD_COLOR_PURPLE;
	colors[13] = BOLD_COLOR_CYAN;
	colors[14] = NULL;
	return (colors);
}

static char	*get_colored_prompt(int color)
{
	char	cwd[PATH_MAX];
	char	*current_dir;
	char	*colored_prompt;
	char	*prompt;
	char	**colors;

	colors = init_colors();
	if (!colors)
		return (NULL);
	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		current_dir = ft_strrchr(cwd, '/');
		if (current_dir != NULL)
			current_dir++;
		else
			current_dir = cwd;
		colored_prompt = ft_strjoin(colors[color % 14], current_dir);
		prompt = ft_strjoin(colored_prompt, " minishell> ");
		free(colored_prompt);
		colored_prompt = ft_strjoin(prompt, RESET_COLOR);
		free(prompt);
	}
	else
		colored_prompt = ft_strdup("minishell>");
	return (free(colors), colored_prompt);
}

char	*reading_line(int color)
{
	char	*line;
	char	*prompt;

	prompt = get_colored_prompt(color);
	line = readline(prompt);
	free(prompt);
	if (line && *line)
		add_history(line);
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_main.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 20:53:02 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/28 13:49:34 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"


int	handle_special_char(char *str, int i, t_arg **current_args)
{
	if (str[i] == '\'')
		return (save_it_single_quoted(str, i, current_args) + 1);
	if (str[i] == '"')
		return (save_it_double_quoted(str, i, current_args) + 1);
	else if (str[i] == '>')
		return (save_it_redir_right(str, i, current_args) + 1);
	else if (str[i] == '<')
		return (save_it_redir_left(str, i, current_args) + 1);
	else
		return (save_it_word(str, i, current_args) + 1);
}

int	parse_one_command(char *str, int i, t_arg **current_args, t_cmd **cmds)
{
	while (str[i] && str[i] != '|')
	{
		if (str[i] == ' ' || str[i] == '\t')
			i++;
		else
		{
			i = handle_special_char(str, i, current_args);
			if (i == -1)
				return (ft_printf("Odd number of quotes\n"), -1);
		}
	}
	add_command(cmds, current_args);
	return (i);
}

int	parse_it(char *str, t_cmd **cmds)
{
	t_arg	*current_args;
	int		i;

	current_args = NULL;
	i = 0;
	if (precheck(str) == 1)
		return (ft_printf("Error with parentheses\n"), -1);
	if (precheck(str) == 2)
		return (ft_printf("Error with pipe position\n"), -1);
	if (precheck(str) == 3)
		return (ft_printf("Incorrect filename\n"), -1);
	while (str[i])
	{
		i = parse_one_command(str, i, &current_args, cmds);
		if (i == -1)
			return (-1);
		if (str[i] == '|')
		{
			if (str[i + 1] == '|')
			{
				current_args = NULL;
				add_arg(&current_args, create_arg("more-than_one_pipe", "error"));
				add_command(cmds, &current_args);
				while (str[i] == '|')
					i++;
			}
			else
			{
				current_args = NULL;
				add_arg(&current_args, create_arg("|", "pipe"));
				add_command(cmds, &current_args);
				i++;
			}
		}
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_save_it.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 20:53:29 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:28:10 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	save_it_word(char *str, int i, t_arg **args)
{
	int		j;
	char	*to_save;
	t_arg	*new_arg;

	j = i;
	while (str[j] && !ft_strchr(" ><'\"", str[j]))
		j++;
	to_save = ft_substr(str, i, j - i);
	new_arg = create_arg(to_save, "word");
	free(to_save);
	add_arg(args, new_arg);
	return (j - 1);
}

int	save_it_double_quoted(char *str, int i, t_arg **args)
{
	int		j;
	t_arg	*arg;
	char	*to_save;

	j = i + 1;
	while (str[j] && (str[j] != '"'))
		j++;
	if (!str[j])
		return (-2);
	to_save = ft_substr(str, i + 1, j - i - 1);
	arg = create_arg(to_save, "double_quoted");
	free(to_save);
	add_arg(args, arg);
	return (j);
}

int	save_it_single_quoted(char *str, int i, t_arg **args)
{
	int		j;
	t_arg	*arg;
	char	*to_save;

	j = i + 1;
	while (str[j] != '\0' && (str[j] != '\''))
		j++;
	if (str[j] == '\0')
		return (-2);
	to_save = ft_substr(str, i + 1, j - i - 1);
	arg = create_arg(to_save, "single_quoted");
	free(to_save);
	add_arg(args, arg);
	return (j);
}

int	save_it_redir_right(char *str, int i, t_arg **args)
{
	if (str[i] && str[i + 1] == '>')
	{
		add_arg(args, create_arg(">>", "double_redir_right"));
		return (i + 1);
	}
	else
	{
		add_arg(args, create_arg(">", "redir_right"));
		return (i);
	}
}

int	save_it_redir_left(char *str, int i, t_arg **args)
{
	if (str[i] && str[i + 1] == '<')
	{
		add_arg(args, create_arg("<<", "double_redir_left"));
		return (i + 1);
	}
	else
	{
		add_arg(args, create_arg("<", "redir_left"));
		return (i);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 02:33:25 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/28 20:38:50 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_arg	*create_arg(char *content, const char *type)
{
	t_arg	*new;

	new = malloc(sizeof(t_arg));
	if (!new)
		return (NULL);
	new->content = ft_strdup(content);
	if (!new->content)
	{
		free(new);
		return (NULL);
	}
	if (ft_strcmp(type, "word") == 0 || ft_strcmp(type, "pipe") == 0
		|| ft_strcmp(type, "command") == 0 || ft_strcmp(type, "file") == 0
		|| ft_strcmp(type, "redir_right") == 0 || ft_strcmp(type,
			"redir_left") == 0)
		new->type = (char *)type;
	else
		new->type = ft_strdup(type);
	new->next = NULL;
	return (new);
}

void	add_arg(t_arg **head, t_arg *new_arg)
{
	t_arg	*current;

	if (!*head)
	{
		*head = new_arg;
	}
	else
	{
		current = *head;
		while (current->next)
		{
			current = current->next;
		}
		current->next = new_arg;
	}
}

void	add_command(t_cmd **cmds, t_arg **current_args)
{
	t_cmd	*new_cmd;
	t_cmd	*last_cmd;

	new_cmd = malloc(sizeof(t_cmd));
	new_cmd->args = *current_args;
	new_cmd->next = NULL;
	if (!*cmds)
		*cmds = new_cmd;
	else
	{
		last_cmd = *cmds;
		while (last_cmd->next)
			last_cmd = last_cmd->next;
		last_cmd->next = new_cmd;
	}
	*current_args = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pre_check.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 21:25:51 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/28 18:19:10 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	check_pipe_position(char *input)
{
	int	i;

	if (!input || !*input)
		return (0);
	if (input[0] == '|')
		return (-1);
	i = 0;
	while (input[i])
	{
		if (input[i] == '|')
		{
			if (i == 0 || (input[i - 1] != ' ' && input[i - 1] != '\t'))
				return (-1);
			if (!input[i + 1])
				return (-1);
		}
		i++;
	}
	return (0);
}

int	precheck(char *input)
{
	if (check_pipe_position(input) == -1)
		return (2);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_filename.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 02:52:31 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:33:32 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_valid_char(char str)
{
	if (!((str >= 65 && str <= 90) || (str >= 97 && str <= 122) || (str >= 48
				&& str <= 57) || str == 95 || str == 46 || str == 45))
	{
		return (-1);
	}
	return (1);
}

int	check_file_name(char *input)
{
	int	i;

	i = 0;
	while (input[i])
	{
		if (is_valid_char(input[i]) == -1)
			return (-1);
		i++;
	}
	return (0);
}

int	error_in_filename(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	int		i;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			i = 0;
			if (ft_strncmp(current_arg->type, "file", 4) == 0)
			{
				if (check_file_name(current_arg->content) == -1)
					return (-1);
			}
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_parentheses.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 02:24:00 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:33:39 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	error_if_unclosed_parentheses(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	int		open_parentheses;
	int		i;

	open_parentheses = 0;
	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			i = 0;
			if (ft_strncmp(current_arg->type, "word", 4) == 0)
			{
				while (current_arg->content[i])
				{
					if (current_arg->content[i] == '(')
						open_parentheses++;
					else if (current_arg->content[i] == ')')
					{
						open_parentheses--;
						if (open_parentheses < 0)
							return (-1);
					}
					i++;
				}
			}
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
	if (open_parentheses != 0)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_expansion.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 14:20:04 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/29 06:44:02 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	replace_env_var(t_arg *current_arg, int start, int end,
		const char *value)
{
	size_t	old_len;
	size_t	val_len;
	size_t	new_len;
	char	*new_str;

	old_len = ft_strlen(current_arg->content);
	val_len = ft_strlen(value);
	new_len = old_len - (end - start) + val_len;
	new_str = malloc(new_len + 1);
	if (!new_str)
		return ;
	ft_strlcpy(new_str, current_arg->content, start + 1);
	ft_strlcpy(new_str + start, value, val_len + 1);
	ft_strlcpy(new_str + start + val_len, current_arg->content + end, old_len
		- end + 1);
	free(current_arg->content);
	current_arg->content = new_str;
}

void	process_env_var(t_arg *current_arg, int *i, t_shell shell)
{
	int			start;
	int			j;
	char		*status_str;
	char		var_name[512];
	const char	*env_value;

	start = *i + 1;
	if (!current_arg->content[start])
	{
		*i = start;
		return ;
	}
	if (current_arg->content[start] == '?')
	{
		status_str = ft_itoa(shell.last_exit_status);
		if (!status_str)
			return ;
		replace_env_var(current_arg, *i, start + 1, status_str);
		*i += ft_strlen(status_str) - 1;
		free(status_str);
		return ;
	}
	j = start;
	while (current_arg->content[j] && (current_arg->content[j] == '_'
			|| (current_arg->content[j] >= 'a'
				&& current_arg->content[j] <= 'z')
			|| (current_arg->content[j] >= 'A'
				&& current_arg->content[j] <= 'Z')
			|| (current_arg->content[j] >= '0'
				&& current_arg->content[j] <= '9')))
		j++;
	if (j == start)
	{
		*i = start;
		return ;
	}
	ft_strlcpy(var_name, current_arg->content + start, j - start + 1);
	env_value = ft_getenv(shell.envp, var_name);
	if (env_value)
	{
		replace_env_var(current_arg, *i, j, env_value);
		*i += ft_strlen(env_value) - 1;
	}
	else
		*i = j - 1;
}

void	expand_env_vars(t_arg *current_arg, t_shell shell)
{
	int	i;

	i = 0;
	if (!current_arg->content)
		return ;
	while (current_arg->content[i])
	{
		if (current_arg->content[i] == '$' && current_arg->content[i + 1]
			&& (current_arg->content[i + 1] == '?' || current_arg->content[i
				+ 1] == '_' || ft_isalnum(current_arg->content[i + 1])))
		{
			process_env_var(current_arg, &i, shell);
		}
		else
		{
			i++;
		}
	}
}

void	expand_env_vars_in_cmds_tab(t_cmd **cmds, t_shell shell)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (ft_strncmp(current_arg->type, "word", 4) == 0
				|| ft_strncmp(current_arg->type, "double_quoted", 13) == 0)
				expand_env_vars(current_arg, shell);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   replace_exit_status.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 02:09:57 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:33:52 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	process_exit_status(t_arg *current_arg, int *i, t_shell *shell)
{
	char	*status_str;
	char	*new_str;
	size_t	old_len;
	size_t	new_len;

	status_str = ft_itoa(shell->exit_status);
	if (!status_str)
		return ;
	old_len = ft_strlen(current_arg->content);
	new_len = old_len - 2 + ft_strlen(status_str);
	new_str = malloc(new_len + 1);
	if (!new_str)
	{
		free(status_str);
		return ;
	}
	ft_strlcpy(new_str, current_arg->content, *i + 1);
	ft_strlcpy(new_str + *i, status_str, ft_strlen(status_str) + 1);
	ft_strlcpy(new_str + *i + ft_strlen(status_str), current_arg->content + *i
		+ 2, old_len - *i - 1);
	*i += ft_strlen(status_str) - 1;
	free(current_arg->content);
	free(status_str);
	current_arg->content = new_str;
}

void	replace_exit_status(t_arg *current_arg, int dolls, t_shell *shell)
{
	int	i;

	if (!current_arg->content)
		return ;
	i = 0;
	while (current_arg->content[i])
	{
		if (current_arg->content[i] == '$')
			dolls++;
		i++;
	}
	while (dolls > 0)
	{
		i = 0;
		while (current_arg->content && current_arg->content[i])
		{
			if (current_arg->content[i] == '$' && current_arg->content[i + 1]
				&& current_arg->content[i + 1] == '?')
			{
				process_exit_status(current_arg, &i, shell);
				dolls--;
			}
			else
				i++;
		}
	}
}

void	replace_exit_status_in_cmds_tab(t_cmd **cmds, t_shell *shell)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (ft_strncmp(current_arg->type, "word", 4) == 0
				|| ft_strncmp(current_arg->type, "double_quoted", 13) == 0)
				replace_exit_status(current_arg, 0, shell);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   subsequent.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 01:06:59 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/25 02:33:55 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_redirect_or_pipe(char *type)
{
	return (ft_strncmp(type, "pipe", 4) == 0 || ft_strncmp(type, "redir_left",
			10) == 0 || ft_strncmp(type, "redir_right", 11) == 0
		|| ft_strncmp(type, "double_redir_left", 16) == 0 || ft_strncmp(type,
			"double_redir_right", 17) == 0);
}

int	error_if_subsequent_commands(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	t_arg	*next_arg;

	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg && current_arg->next)
		{
			next_arg = current_arg->next;
			if (is_redirect_or_pipe(current_arg->type)
				&& is_redirect_or_pipe(next_arg->type))
				return (-1);
			current_arg = current_arg->next;
		}
		current_cmd = current_cmd->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   words_to_file.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 00:36:43 by dmathis           #+#    #+#             */
/*   Updated: 2024/10/23 03:12:37 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	type_to_file_in_args1(t_cmd **cmds)
{
	t_cmd	*current_cmd;
	t_arg	*current_arg;
	int		flag;

	flag = 0;
	current_cmd = *cmds;
	while (current_cmd)
	{
		current_arg = current_cmd->args;
		while (current_arg)
		{
			if (ft_strncmp(current_arg->type, "redir_right", 11) == 0 || ft_strncmp(current_arg->type, "double_redir_right", 18) == 0 || ft_strncmp(current_arg->type, "redir_left", 10) == 0 || ft_strncmp(current_arg->type, "double_redir_left", 17) == 0)
				flag = 1;
			current_arg = current_arg->next;
			if (flag == 1)
				current_arg->type = "file";
			flag = 0;
		}
		current_cmd = current_cmd->next;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_all.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 17:57:08 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/28 23:02:34 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_cmd_arg_stdin(char **cmd_arg_stdin)
{
	int	i;

	if (!cmd_arg_stdin)
		return ;
	i = 0;
	while (cmd_arg_stdin[i])
	{
		free(cmd_arg_stdin[i]);
		i++;
	}
	free(cmd_arg_stdin);
}

void	free_args(t_arg *args)
{
	t_arg	*current;
	t_arg	*next;

	if (!args)
		return ;
	current = args;
	while (current)
	{
		next = current->next;
		if (current->content)
		{
			free(current->content);
			current->content = NULL;
		}
		if (current->type && ft_strcmp(current->type, "word") != 0
			&& ft_strcmp(current->type, "pipe") != 0 && ft_strcmp(current->type,
				"command") != 0 && ft_strcmp(current->type, "file") != 0
			&& ft_strcmp(current->type, "redir_right") != 0
			&& ft_strcmp(current->type, "redir_left") != 0)
		{
			free(current->type);
			current->type = NULL;
		}
		free(current);
		current = next;
	}
}

void	safe_free_cmds(t_cmd *cmds)
{
	t_cmd	*current_cmd;
	t_cmd	*next_cmd;

	current_cmd = cmds;
	while (current_cmd)
	{
		next_cmd = current_cmd->next;
		if (current_cmd->args)
			free_args(current_cmd->args);
		if (current_cmd->cmd_arg_stdin)
			safe_free_all_strings(&(current_cmd->cmd_arg_stdin));
		ft_safe_free((void **)&current_cmd);
		current_cmd = next_cmd;
	}
}

void	free_pipes(int **pipes, int nbr_pipes)
{
	int	i;

	if (!pipes)
		return ;
	for (i = 0; i < nbr_pipes; i++)
	{
		ft_safe_free((void **)&(pipes[i]));
	}
	ft_safe_free((void **)&pipes);
}

void	clean_all(t_shell *shell)
{
	char	**ptr;

	if (!shell)
		return ;
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
	// Ne pas nettoyer cmds si déjà NULL
	if (shell->cmds)
	{
		safe_free_cmds(shell->cmds);
		shell->cmds = NULL;
	}
	if (shell->pipes)
	{
		free_pipes(shell->pipes, shell->nbr_pipes);
		shell->pipes = NULL;
	}
	if (shell->envp)
	{
		ptr = shell->envp;
		while (*ptr)
			free(*ptr++);
		free(shell->envp);
		shell->envp = NULL;
	}
	rl_cleanup_after_signal();
	rl_deprep_terminal();
	free(shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   count_cmds.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/27 19:03:54 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/27 19:06:34 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_cmd(t_cmd *cmd)
{
	int		nbr_cmd;
	t_arg	*arg;

	nbr_cmd = 0;
	while (cmd)
	{
		arg = cmd->args;
		while (arg)
		{
			if (ft_strcmp(arg->type, "command") == 0)
			{
				nbr_cmd++;
				break ;
			}
			arg = arg->next;
		}
		cmd = cmd->next;
	}
	return (nbr_cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cut_the_cmd_plus_arg.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 15:11:30 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/25 03:00:58 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_arguments_for_t_arg(t_arg *args)
{
	int	count;

	count = 0;
	while (args)
	{
		count++;
		args = args->next;
	}
	return (count);
}

// Including the cmd
int	how_many_args(t_arg *args)
{
	int	count;

	count = 0;
	while (args && ft_strcmp(args->type, "command") != 0)
		args = args->next;
	if (args == NULL)
		return (0);
	while (args && is_redir(args) == 0)
	{
		count++;
		args = args->next;
	}
	return (count);
}

// Démarrer à l'endroit où il y a "command" puis continuer jusqu'à trouver
// un < << > >> ou NULL
int	cut_the_cmd_plus_args(t_cmd *cmd)
{
	t_arg	*current;
	char	**cmd_plus_args;
	int		i;

	current = cmd->args;
	cmd_plus_args = malloc(sizeof(char *) * (how_many_args(current) + 1));
	if (!cmd_plus_args)
		return (-1);
	i = 0;
	while (current && ft_strcmp(current->type, "command") != 0)
		current = current->next;
	if (!current)
	{
		free(cmd_plus_args);
		return (-1);
	}
	while (current && is_redir(current) == 0)
	{
		cmd_plus_args[i] = ft_strdup(current->content); // Dupliquer le contenu
		if (!cmd_plus_args[i])
		{
			while (--i >= 0)
				free(cmd_plus_args[i]);
			free(cmd_plus_args);
			return (-1);
		}
		i++;
		current = current->next;
	}
	cmd_plus_args[i] = NULL;
	cmd->cmd_arg_stdin = cmd_plus_args;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   edit_args_for_export.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 11:37:44 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/27 18:58:00 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Carrement creer un nouveau t_arg ca sera plus simple.
// void	edit_args_for_export(t_arg *args)
// {
// 	while (args && args->next)
// 	{
// 		if (ft_strcmp(args->next->type, "double_quoted") == 0
// 			|| ft_strcmp(args->next->type, "single_quoted") == 0)
// 			args->content = ft_strjoin(args->content, args->next->content);
// 		args = args->next;
// 	}
// }

void	edit_args_for_export(t_arg *args)
{
	t_arg	*tmp;

	while (args && args->next)
	{
		if (ft_strcmp(args->next->type, "double_quoted") == 0
			|| ft_strcmp(args->next->type, "single_quoted") == 0)
		{
			tmp = args->next;
			args->content = ft_strjoin(args->content, tmp->content);
			args->next = tmp->next;
			free(tmp->content);
			free(tmp);
		}
		else
			args = args->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_add_add_type_cmd.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 11:34:35 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/28 21:08:39 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void find_arg_add_type_cmd(t_shell *shell, t_arg *args)
{
    t_arg *tmp;
    char *path;

    tmp = args;
    while (tmp)
    {
        if (strcmp(tmp->type, "file") == 0)
        {
            tmp = tmp->next;
            continue;
        }
        if (is_built_in_t_args(tmp) == 1)
        {
            tmp->type = "command";
        }
        else if (is_absolute_or_relative_path(tmp->content))
        {
            path = handle_absolute_or_relative_path(tmp->content);
            if (path != NULL)
            {
                tmp->type = "command";
                free(path);
            }
        }
        else
        {
            path = find_command_path(shell, tmp->content, shell->envp);
            if (path != NULL)
            {
                tmp->type = "command";
                free(path); // Libérer la chaîne allouée
            }
			else
            {
                if (path)
                    free(path);
			}
        }
        tmp = tmp->next;
    }
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_getenv.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 06:36:41 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 06:49:33 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_getenv(char **env, char *name)
{
	int	i;
	int	j;

	i = 0;
	while (env[i])
	{
		j = 0;
		while (name[j] && env[i][j] && name[j] == env[i][j])
			j++;
		if (name[j] == '\0' && env[i][j] == '=')
			return (&env[i][j + 1]);
		i++;
	}
	return (NULL);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_real_cmd_in_cmds.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 07:09:10 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/29 07:09:54 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_real_cmd_in_cmds(t_cmd *cmds)
{
	t_arg	*arg;

	while (cmds)
	{
		arg = cmds->args;
		while (arg)
		{
			if (ft_strcmp(arg->type, "command") == 0)
				return (1);
			arg = arg->next;
		}
		cmds = cmds->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_redir.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 14:48:26 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/20 14:49:48 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_redir(t_arg *arg)
{
	if (ft_strcmp(arg->type, "redir_right") == 0)
		return (1);
	if (ft_strcmp(arg->type, "double_redir_right") == 0)
		return (1);
	if (ft_strcmp(arg->type, "redir_left") == 0)
		return (1);
	if (ft_strcmp(arg->type, "here_doc") == 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_counter.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 19:39:41 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/22 04:54:02 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_pipe(t_cmd *cmd)
{
	int	nbr_pipe;

	nbr_pipe = 0;
	while (cmd && ft_strcmp(cmd->args->type, "semicolon") != 0)
	{
		if (ft_strcmp(cmd->args->type, "pipe") == 0)
			nbr_pipe++;
		cmd = cmd->next;
	}
	return (nbr_pipe);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_args.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 20:00:37 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 03:15:14 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_args(t_arg *args)
{
	printf("[");
	while (args)
	{
		printf("content : '%s', type : '%s'", args->content, args->type);
		if (args->next)
			printf(", ");
		args = args->next;
	}
	printf("]");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   t_env_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 06:18:27 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 07:08:00 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char    *get_env_name(char *env_line)
{
    int     i;
    char    *name;
    int     j;

    i = 0;
    while (env_line[i] && env_line[i] != '=')
        i++;
    name = (char *)malloc(sizeof(char) * (i + 1));
    if (!name)
        return (NULL);
    j = 0;
    while (j < i)
    {
        name[j] = env_line[j];
        j++;
    }
    name[j] = '\0';
    return (name);
}

char    *get_env_value(char *env_line)
{
    int     i;
    char    *value;

    i = 0;
    while (env_line[i] && env_line[i] != '=')
        i++;
    if (env_line[i] == '\0')
        return (NULL);
    value = ft_strdup(env_line + i + 1);
    return (value);
}

t_env   *create_node(char *env_line)
{
    t_env   *node;

    node = (t_env *)malloc(sizeof(t_env));
    if (!node)
        return (NULL);
    node->line = ft_strdup(env_line);
    if (!node->line)
        return (free(node), NULL);
    node->name = get_env_name(env_line);
    if (!node->name)
        return (free(node->line), free(node), NULL);
    node->value = get_env_value(env_line);
    if (!node->value && strchr(env_line, '=') != NULL)
        return (free(node->name),free(node->line), free(node), NULL);
    node->next = NULL;
    return (node);
}

t_env   *add_node(t_env *head, t_env *new_node)
{
    t_env   *current;

    if (!head)
        return (new_node);
    current = head;
    while (current->next)
        current = current->next;
    current->next = new_node;
    return (head);
}

t_env   *create_t_env(char **envp)
{
    t_env   *head;
    t_env   *new_node;
    int     i;

    head = NULL;
    i = 0;
    while (envp[i])
    {
        new_node = create_node(envp[i]);
        if (!new_node)
            return (NULL);
        head = add_node(head, new_node);
        i++;
    }
    return (head);
}
