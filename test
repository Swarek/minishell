/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 17:57:08 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 04:46:31 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void free_args(t_arg *args)
{
    t_arg *current_arg;
    t_arg *next_arg;

    current_arg = args;
    while (current_arg)
    {
        next_arg = current_arg->next;
        ft_safe_free((void**)&(current_arg->content));
        if (current_arg->type && 
            (strcmp(current_arg->type, "command") != 0 &&
             strcmp(current_arg->type, "file") != 0 &&
             strcmp(current_arg->type, "redir_right") != 0 &&
             strcmp(current_arg->type, "double_redir_right") != 0 &&
             strcmp(current_arg->type, "redir_left") != 0 &&
             strcmp(current_arg->type, "double_redir_left") != 0 &&
             strcmp(current_arg->type, "here_doc") != 0 &&
             strcmp(current_arg->type, "pipe") != 0 &&
             strcmp(current_arg->type, "semicolon") != 0))
        {
            ft_safe_free((void**)&(current_arg->type));
        }
        ft_safe_free((void**)&current_arg); // Free the t_arg node
        current_arg = next_arg;
    }
}

void safe_free_cmds(t_cmd *cmds)
{
    t_cmd *current_cmd;
    t_cmd *next_cmd;

    current_cmd = cmds;
    while (current_cmd)
    {
        next_cmd = current_cmd->next;
        if (current_cmd->args)
            free_args(current_cmd->args);
        if (current_cmd->cmd_arg_stdin)
            safe_free_all_strings(&(current_cmd->cmd_arg_stdin));
        ft_safe_free((void**)&current_cmd);
        current_cmd = next_cmd;
    }
}

void free_pipes(int **pipes, int nbr_pipes)
{
    int i;

    if (!pipes)
        return;
    for (i = 0; i < nbr_pipes; i++)
    {
        ft_safe_free((void**)&(pipes[i]));
    }
    ft_safe_free((void**)&pipes);
}

void clean_all(t_shell *shell)
{
    if (!shell)
        return;
    if (shell->envp)
        safe_free_all_strings(&(shell->envp));
    if (shell->cmds)
        safe_free_cmds(shell->cmds);
    if (shell->pipes)
        free_pipes(shell->pipes, shell->nbr_pipes);
    ft_safe_free((void**)&(shell->child_pids));
    ft_safe_free((void**)&shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cut_the_cmd_plus_arg.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 15:11:30 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 03:46:59 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Including the cmd
int how_many_args(t_arg *args)
{
    int count;

    count = 0;
    while (args && ft_strcmp(args->type, "command") != 0)
        args = args->next;
    if (args == NULL)
        return (0);
    while (args && is_redir(args) == 0)
    {
        count++;
        args = args->next;
    }
    return (count);
}

// Démarrer à l'endroit où il y a "command" puis continuer jusqu'à trouver
// un < << > >> ou NULL
int cut_the_cmd_plus_args(t_cmd *cmd)
{
    t_arg *current;
    char **cmd_plus_args;
    int i;

    current = cmd->args;
    cmd_plus_args = malloc(sizeof(char *) * (how_many_args(current) + 1));
    if (cmd_plus_args == NULL)
        return (-1);
    i = 0;
    while (current && ft_strcmp(current->type, "command") != 0)
        current = current->next;
    if (current == NULL)
    {
        free(cmd_plus_args); // Libérer la mémoire allouée
        return (-1);
    }
    while (current && is_redir(current) == 0)
    {
        cmd_plus_args[i++] = current->content;
        current = current->next;
    }
    cmd_plus_args[i] = NULL;
    cmd->cmd_arg_stdin = cmd_plus_args;
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_add_add_type_cmd.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 11:34:35 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 03:46:40 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void find_arg_add_type_cmd(t_shell *shell, t_arg *args, char **envp)
{
    t_arg *tmp;
    char *path;

    tmp = args;
    while (tmp)
    {
        if (strcmp(tmp->type, "file") == 0)
        {
            tmp = tmp->next;
            continue;
        }
        if (is_built_in_t_args(tmp) == 1)
        {
            tmp->type = "command";
        }
        else if (is_absolute_or_relative_path(tmp->content))
        {
            path = handle_absolute_or_relative_path(tmp->content);
            if (path != NULL)
            {
                tmp->type = "command";
                free(path); // Libérer la chaîne allouée
            }
        }
        else
        {
            path = find_command_path(shell, tmp->content, envp);
            if (path != NULL)
            {
                tmp->type = "command";
                free(path); // Libérer la chaîne allouée
            }
        }
        tmp = tmp->next;
    }
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   is_redir.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 14:48:26 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/20 14:49:48 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_redir(t_arg *arg)
{
	if (ft_strcmp(arg->type, "redir_right") == 0)
		return (1);
	if (ft_strcmp(arg->type, "double_redir_right") == 0)
		return (1);
	if (ft_strcmp(arg->type, "redir_left") == 0)
		return (1);
	if (ft_strcmp(arg->type, "here_doc") == 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_counter.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 19:39:41 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/22 04:54:02 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	count_pipe(t_cmd *cmd)
{
	int	nbr_pipe;

	nbr_pipe = 0;
	while (cmd && ft_strcmp(cmd->args->type, "semicolon") != 0)
	{
		if (ft_strcmp(cmd->args->type, "pipe") == 0)
			nbr_pipe++;
		cmd = cmd->next;
	}
	return (nbr_pipe);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_args.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/18 20:00:37 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 03:15:14 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_args(t_arg *args)
{
	printf("[");
	while (args)
	{
		printf("content : '%s', type : '%s'", args->content, args->type);
		if (args->next)
			printf(", ");
		args = args->next;
	}
	printf("]");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execution.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/06 02:55:26 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 22:43:57 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fonction pour exécuter la commande
static void	execute_command(t_shell *shell, t_cmd *cmd, char *path)
{
	if (execve(path, cmd->cmd_arg_stdin, shell->envp) == -1)
	{
		if (access(path, F_OK) == 0 && access(path, X_OK) != 0)
		{
			free(path);
			perror("execve error");
			exit(126);
		}
		free(path);
		perror("execve error");
		exit(127);
	}
}

// Fonction auxiliaire pour préparer l'exécution
static char	*prepare_execution(t_shell *shell, t_cmd *cmd)
{
	char	*path;

	if (!cmd || !cmd->args || !cmd->args->content)
	{
		perror("Command content is NULL");
		exit(127);
	}
	path = find_command_path(shell, cmd->cmd_arg_stdin[0], shell->envp);
	if (!path)
	{
		perror("execve error");
		exit(shell->exit_status);
	}
	if (!cmd->cmd_arg_stdin)
	{
		perror("Command arguments are NULL");
		free(path);
		exit(127);
	}
	return (path);
}

// Fonction principale pour effectuer l'exécution
int	do_the_execution(t_shell *shell, t_cmd *cmd, char **envp)
{
	char	*path;

	(void)envp;
	path = prepare_execution(shell, cmd);
	execute_command(shell, cmd, path);
	// La fonction execve ne retourne pas si elle réussit
	free(path);
	return (0);
}

// Fonction pour exécuter une commande seule
int	execute_solo(t_shell *shell)
{
	pid_t	pid;
	int		status;

	pid = fork();
	if (pid == -1)
	{
		error_msg("Fork failed\n");
		shell->exit_status = 1;
		return (-1);
	}
	if (pid == 0)
	{
		setup_child_signals();
		dup2(shell->infile, STDIN_FILENO);
		dup2(shell->outfile, STDOUT_FILENO);
		if (do_the_execution(shell, shell->cmds, shell->envp) == -1)
			exit(1);
	}
	else
	{
		waitpid(pid, &status, 0);
		if (WIFEXITED(status))
			shell->exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			shell->exit_status = 128 + WTERMSIG(status);
		else
			shell->exit_status = 1;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   setup_file_redirections.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 06:35:42 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 21:37:21 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_arg	*last_redir_left(t_arg *args)
{
	t_arg	*last_redir_left;

	last_redir_left = NULL;
	while (args)
	{
		if (ft_strcmp(args->type, "redir_left") == 0)
			last_redir_left = args;
		if (ft_strcmp(args->type, "double_redir_left") == 0)
			last_redir_left = args;
		args = args->next;
	}
	return (last_redir_left);
}

t_arg	*last_redir_right(t_arg *args)
{
	t_arg	*last_redir_right;

	last_redir_right = NULL;
	while (args)
	{
		if (ft_strcmp(args->type, "redir_right") == 0)
			last_redir_right = args;
		if (ft_strcmp(args->type, "double_redir_right") == 0)
			last_redir_right = args;
		args = args->next;
	}
	return (last_redir_right);
}

static int	handle_input_redirection(t_shell *shell, t_arg *redir_left)
{
	if (redir_left != NULL)
	{
		if (ft_strcmp(redir_left->type, "double_redir_left") == 0)
		{
			here_doc_management(redir_left->next->content);
			shell->infile = open("temp.txt", O_RDONLY);
		}
		else
			shell->infile = open(redir_left->next->content, O_RDONLY);
		if (shell->infile < 0)
		{
			shell->exit_status = 1; // Code de sortie pour une erreur d'ouverture du fichier d'entrée
			error_msg("Failed to open infile\n");
			return (-1);
		}
	}
	else
	{
		shell->infile = STDIN_FILENO;
	}
	return (0);
}

static int	handle_output_redirection(t_shell *shell, t_arg *redir_right)
{
	if (redir_right != NULL)
	{
		if (ft_strcmp(redir_right->type, "redir_right") == 0)
			shell->outfile = open(redir_right->next->content,
								  O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (ft_strcmp(redir_right->type, "double_redir_right") == 0)
			shell->outfile = open(redir_right->next->content,
								  O_WRONLY | O_CREAT | O_APPEND, 0644);
		if (shell->outfile < 0)
		{
			shell->exit_status = 1;
			error_msg("Failed to open outfile\n");
			return (-1);
		}
	}
	else
	{
		shell->outfile = STDOUT_FILENO;
	}
	return (0);
}

int	handle_io_redirections(t_shell *shell)
{
	t_arg	*redir_left;
	t_arg	*redir_right;

	// print_all_commands(shell->cmds);
	redir_left = last_redir_left(shell->cmds->args);
	redir_right = last_redir_right(shell->cmds->args);
	if (handle_input_redirection(shell, redir_left) == -1)
		return (-1);
	if (handle_output_redirection(shell, redir_right) == -1)
	{
		if (redir_left != NULL && shell->infile != STDIN_FILENO)
			close(shell->infile);
		return (-1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_pipe_without_out_redirection.c              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/21 18:41:49 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 22:10:22 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int setup_pipe_redirections(t_shell *shell)
{
	// Première commande
	if (shell->n_th_cmd == 0)
	{
		if (dup2(shell->infile, STDIN_FILENO) == -1
			|| dup2(shell->pipes[shell->n_th_cmd][1], STDOUT_FILENO) == -1)
			return (-1);
	}
	// Dernière commande
	else if (shell->n_th_cmd == shell->total_cmd_count - 1)
	{
		if (dup2(shell->pipes[shell->n_th_cmd - 1][0], STDIN_FILENO) == -1
			|| dup2(shell->outfile, STDOUT_FILENO) == -1)
			return (-1);
	}
	// Commandes intermédiaires
	else
	{
		if (dup2(shell->pipes[shell->n_th_cmd - 1][0], STDIN_FILENO) == -1
			|| dup2(shell->pipes[shell->n_th_cmd][1], STDOUT_FILENO) == -1)
			return (-1);
	}	
	return (0);
}


// return 1 if a pipe is coming, 0 otherwise
int	handle_pipe_without_out_redirection(t_shell *shell)
{
	t_cmd *cmd;

	cmd = shell->cmds;
	// print_all_commands(shell->cmds);
	setup_pipe_redirections(shell);
	close_pipes(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   here_doc_management.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/08 04:54:57 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/18 16:38:21 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

static int	write_to_temp(int fd, char *line)
{
	if (write(fd, line, ft_strlen(line)) == -1)
		return (error_msg("Problem writing to temp.txt"),
			free(line), close(fd), -1);
	if (write(fd, "\n", 1) == -1)
		return (error_msg("Problem writing newline to temp.txt"),
			free(line), close(fd), -1);
	return (0);
}

int	here_doc_management(char *limiter)
{
	int		fd;
	char	*line;
	size_t	len;

	fd = open("temp.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
		return (error_msg("Problem opening temp.txt"));
	while (1)
	{
		write(1, "> ", 2);
		line = get_next_line(0);
		if (!line)
			break ;
		len = ft_strlen(line);
		if (len > 0 && line[len - 1] == '\n')
			line[len - 1] = '\0';
		if (ft_strcmp(line, limiter) == 0 || len == 0)
			break ;
		if (write_to_temp(fd, line) == -1)
			return (-1);
		free(line);
	}
	free(line);
	close(fd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_everything.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 03:06:09 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 03:36:18 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	clean_up_for_error_init(t_shell *shell, int pipe_count)
{
	int	i;

	if (shell->pipes)
	{
		i = 0;
		while (i < pipe_count)
		{
			if (shell->pipes[i])
				free(shell->pipes[i]);
			i++;
		}
		free(shell->pipes);
		shell->pipes = NULL;
	}
	if (shell->child_pids)
	{
		free(shell->child_pids);
		shell->child_pids = NULL;
	}
}

int init_pipes(t_shell *shell)
{
    int i;

    // Vérifier si le nombre de pipes est supérieur à 0
    if (shell->nbr_pipes <= 0)
    {
        shell->pipes = NULL;
        return (0);
    }

    shell->pipes = malloc(sizeof(int *) * shell->nbr_pipes);
    if (!shell->pipes)
        return (error_msg("Memory allocation failed\n"), -1);
    i = 0;
    while (i < shell->nbr_pipes)
    {
        shell->pipes[i] = malloc(2 * sizeof(int));
        if (!shell->pipes[i])
        {
            clean_up_for_error_init(shell, i);  // Nettoyer les pipes alloués partiellement
            return (error_msg("Memory allocation failed\n"), -1);
        }
        if (pipe(shell->pipes[i]) == -1)
        {
            clean_up_for_error_init(shell, i);  // Nettoyer les pipes alloués partiellement
            return (error_msg("Pipe creation failed\n"), -1);
        }
        i++;
    }
    return (0);
}

int init_child_pids(t_shell *shell)
{
    if (shell->total_cmd_count <= 0)
    {
        shell->child_pids = NULL;
        return (0);
    }

    shell->child_pids = malloc(sizeof(pid_t) * shell->total_cmd_count);
    if (!shell->child_pids)
    {
        clean_up_for_error_init(shell, shell->nbr_pipes);
        return (error_msg("Memory allocation failed\n"), -1);
    }
    return (0);
}


void	initiates_type_cmd(t_shell *shell)
{
	int		i;
	t_cmd	*tmp;
	
	i = 0;
	if (shell == NULL)
		return ;
	tmp = shell->cmds;
	while (tmp)
	{
		find_arg_add_type_cmd(shell, tmp->args, shell->envp);
		tmp = tmp->next;
	}
}

int	all_init(t_shell *shell)
{
	shell->nbr_pipes = count_pipe(shell->cmds);
	shell->total_cmd_count = shell->nbr_pipes + 1;
	shell->pipes = NULL;
	shell->child_pids = NULL;
	shell->there_is_redir_out = 0;
	shell->n_th_cmd = 0;
	if (init_pipes(shell) == -1)
		return (-1);
	if (init_child_pids(shell) == -1)
		return (-1);
	initiates_type_cmd(shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   path.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 22:32:29 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 03:57:40 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fonction auxiliaire pour créer le chemin complet de la commande
static char *create_command_path(char *path, char *command)
{
    char *temp;
    char *full_path;

    if (path == NULL)
        return (NULL);
    if (path[strlen(path) - 1] != '/')
    {
        temp = ft_strjoin(path, "/");
        if (!temp)
            return (NULL);
    }
    else
    {
        temp = ft_strdup(path);
    }
    if (!temp)
        return (NULL);
    full_path = ft_strjoin(temp, command);
    free(temp); // Free temp after use
    return (full_path);
}

// Fonction auxiliaire pour vérifier l'accès au chemin de la commande
static char *verify_command_access(t_shell *shell, char *path, char *command)
{
    char *command_path;

    if (!path)
    {
        shell->exit_status = 127;
        return (NULL);
    }
    command_path = create_command_path(path, command);
    if (!command_path)
    {
        free(path);
        shell->exit_status = 12;
        return (NULL);
    }
    if (access(command_path, X_OK) == 0)
    {
        free(path);
        return (command_path);
    }
    if (access(command_path, F_OK) == 0)
        shell->exit_status = 126;
    else
        shell->exit_status = 127;
    free(command_path);
    free(path); // Ensure path is freed in all cases
    return (NULL);
}


// Nouvelle fonction pour rechercher la commande dans PATH
static char	*search_in_path(t_shell *shell, char *command, char **paths)
{
	int		i;
	char	*command_path;

	i = 0;
	while (paths[i] != NULL)
	{
		command_path = verify_command_access(shell, ft_strdup(paths[i]),
				command);
		if (command_path)
		{
			safe_free_all_strings(&paths);
			return (command_path);
		}
		i++;
	}
	return (NULL);
}

// Fonction pour trouver le chemin de la commande
char	*get_path_from_env(t_shell *shell, char *command, char **envp)
{
	char	**paths;
	char	*command_path;
	int		i;

	i = 0;
	while (envp[i] != NULL && ft_strncmp(envp[i], "PATH=", 5) != 0)
		i++;
	if (!envp[i])
	{
		shell->exit_status = 127;
		return (NULL);
	}
	paths = ft_split(envp[i] + 5, ':');
	if (paths == NULL)
	{
		shell->exit_status = 12;
		return (NULL);
	}
	command_path = search_in_path(shell, command, paths);
	if (command_path)
		return (command_path);
	safe_free_all_strings(&paths);
	shell->exit_status = 127;
	return (NULL);
}

char	*find_command_path(t_shell *shell, char *command, char **envp)
{
	if (!command || *command == '\0' || ft_str_is_whitespace(command))
	{
		shell->exit_status = 127;
		return (NULL);
	}
	if (is_absolute_or_relative_path(command))
	{
		if (access(command, F_OK) == 0 && access(command, X_OK) != 0)
		{
			shell->exit_status = 126;
			return (NULL);
		}
		if (access(command, X_OK) == 0)
			return (ft_strdup(command));
		shell->exit_status = 127;
		return (NULL);
	}
	return (get_path_from_env(shell, command, envp));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_process.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/20 22:14:46 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 22:10:12 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	parent_process(t_shell *shell, pid_t pid)
{
	shell->child_pids[shell->n_th_cmd] = pid;
	return (0);
}

void close_pipes(t_shell *shell)
{
	int i;

	i = 0;
	while (i < shell->total_cmd_count - 1)
	{
		close(shell->pipes[i][0]);
		close(shell->pipes[i][1]);
		i++;
	}
}

void	child_process(t_shell *shell)
{
	setup_child_signals();
	shell->there_is_redir_out = handle_io_redirections(shell);
	if (shell->there_is_redir_out < 0)
	{
		error_msg("Error setup redirection\n");
		exit(EXIT_FAILURE);
	}
	cut_the_cmd_plus_args(shell->cmds);
	if (shell->there_is_redir_out)
	{
		dup2(shell->infile, STDIN_FILENO);
		dup2(shell->outfile, STDOUT_FILENO);
	}
	else
		handle_pipe_without_out_redirection(shell);
	if (do_the_execution(shell, shell->cmds, shell->envp) == -1)
			exit(1);
}

int	advance_to_next_command(t_shell *shell)
{
	if (shell->cmds->args)
	{
		while (shell->cmds && ft_strcmp(shell->cmds->args->type, "pipe") != 0)
			shell->cmds = shell->cmds->next;
		if (shell->cmds)
			shell->cmds = shell->cmds->next;
	}
	else
		return (-1);
	return (0);
}

int	fork_process(t_shell *shell)
{
	pid_t	pid;

	shell->infile = dup(STDIN);
	shell->outfile = dup(STDOUT);
	while (shell->cmds)
	{
		pid = fork();
		if (pid == -1)
			return (error_msg("Fork failed\n"), -1);
		if (pid == 0)
			child_process(shell);
		else
			parent_process(shell, pid);
		shell->n_th_cmd++;
		if (advance_to_next_command(shell) == -1)
			break;
	}
	close_pipes(shell);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   relative_absolute_path.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/16 11:11:50 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 09:45:33 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "pipex.h"

static char	**build_new_cmd(char *path, char **cmd, int args_count)
{
	char	**new_cmd;
	int		j;

	new_cmd = malloc(sizeof(char *) * (args_count + 2));
	if (!new_cmd)
		return (NULL);
	new_cmd[0] = ft_strdup("/bin/sh");
	new_cmd[1] = ft_strdup(path);
	j = 1;
	while (j < args_count)
	{
		new_cmd[j + 1] = ft_strdup(cmd[j]);
		j++;
	}
	new_cmd[args_count + 1] = NULL;
	return (new_cmd);
}

int	execute_with_shell(char *path, char **cmd, char **envp, int args_count)
{
	char	**new_cmd;
	int		j;

	new_cmd = build_new_cmd(path, cmd, args_count);
	if (!new_cmd)
	{
		perror("malloc error");
		exit(12);
	}
	execve("/bin/sh", new_cmd, envp);
	perror("execve error");
	j = 0;
	while (new_cmd[j])
	{
		free(new_cmd[j]);
		j++;
	}
	free(new_cmd);
	return (-1);
}

int	is_absolute_or_relative_path(char *command)
{
	if (!command)
		return (0);
	return (command[0] == '/' || (command[0] == '.' && command[1] == '/')
		|| (command[0] == '.' && command[1] == '.' && command[2] == '/'));
}

char	*handle_absolute_or_relative_path(char *command)
{
	if (access(command, X_OK) == 0)
		return (ft_strdup(command));
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   solo_cmd.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 21:22:35 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 03:43:45 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// After variables are set, we will call this function to execute the command
// This function will check if the command is a built-in, and execute it if it is
// If it is not, it will execute the command with execve
static int	single_cmd(t_shell *shell)
{
	t_arg	*current;

	current = shell->cmds->args;
	while (current && ft_strcmp(current->type, "command") != 0)
		current = current->next;
	if (!current)
		return (execute_solo(shell));
	if (is_built_in(shell->cmds->cmd_arg_stdin))
	{
		shell->exit_status = execute_built_in(shell, shell->cmds->cmd_arg_stdin, &shell->envp);
		return (shell->exit_status);
	}
	else
	{
		execute_solo(shell);
		return (shell->exit_status);
	}
}

// Iniatiate all needed and call single_cmd to exec
int starting_one_cmd(t_shell *shell)
{
    int i;

    i = 0;
    if (shell == NULL || shell->cmds == NULL || shell->cmds->args == NULL)
        return (-1);
    if (handle_io_redirections(shell) == -1)
        return (-1);
    if (all_init(shell) == -1)
    {
        shell->exit_status = 1;
        clean_all(shell); // Nettoyer en cas d'échec d'initialisation
        return (-1);
    }
    // print_all_commands(shell->cmds);
    cut_the_cmd_plus_args(shell->cmds);
    if (single_cmd(shell) == -1)
    {
        clean_all(shell); // Nettoyer en cas d'erreur dans single_cmd
        return (-1);
    }
    return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_exec.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/17 23:04:23 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/23 22:11:37 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	exec_it(t_shell *shell)
{
	if (shell == NULL || shell->cmds == NULL || shell->cmds->args == NULL)
		return (-1);
	all_init(shell);
	if (shell->nbr_pipes == 0)
	{
		if (starting_one_cmd(shell) == -1)
			return (-1);
	}
	else if (shell->nbr_pipes >= 1)
	{
		fork_process(shell);
		wait_and_cleanup(shell);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wait_and_cleanup_pipes.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mblanc <mblanc@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 02:49:55 by mblanc            #+#    #+#             */
/*   Updated: 2024/10/24 03:58:20 by mblanc           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	wait_and_cleanup(t_shell *shell)
{
	int	i;
	int	status;

	i = 0;
	while (i < shell->total_cmd_count)
	{
		if (waitpid(shell->child_pids[i], &status, 0) == -1)
		{
			error_msg("Waitpid failed\n");
			shell->exit_status = 1;
		}
		else if (i == shell->total_cmd_count - 1)
		{
			if (WIFEXITED(status))
			{
				shell->exit_status = WEXITSTATUS(status);
				ft_printf("shell->exit_status = %d\n", shell->exit_status);
			}
			else if (WIFSIGNALED(status))
			{
				shell->exit_status = 128 + WTERMSIG(status);
				ft_printf("shell->exit_status = %d\n", shell->exit_status);
			}
		}
		i++;
	}
	ft_printf("shell->exit_status = %d\n", shell->exit_status);
	cleanup(shell, NULL);
	if (shell->infile != -1)
		close(shell->infile);
	if (shell->outfile != -1)
		close(shell->outfile);
}


void	cleanup(t_shell *shell, char **cmd)
{
	int	i;

	i = 0;
	while (i < shell->nbr_pipes)
	{
		if (shell->pipes[i])
		{
			close(shell->pipes[i][0]);
			close(shell->pipes[i][1]);
			free(shell->pipes[i]);
		}
		i++;
	}
	free(shell->pipes);
	shell->pipes = NULL;
	if (shell->infile != -1)
		close(shell->infile);
	if (cmd)
		safe_free_all_strings(&cmd);
	if (shell->outfile != -1)
		close(shell->outfile);
	if (shell->child_pids)
		ft_safe_free((void**)&(shell->child_pids));
	ft_safe_free((void**)&shell);
}
